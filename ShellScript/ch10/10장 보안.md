# 10장 보안

```
근래 들어 시스템은 가상화 환경으로 점점 바뀌어 가고 있으며,
점점 더 많음 업무가 웹 상에서 처리가 가능하도록 시스템화 되어 가고 있음.
기업의 중요 고객 정보는 서버의 테이터베이스에 저장되고
쇼핑, 은행업무, 공공기관 업무들이 웹 어플리케이션을 통해 처리되고 있음.
따라서, 과거에 비해 보안은 매우 중요한 업무가 되었고, 그 중 가장 기본적인 보안이 바로 운영체제 보안일 것.
```



## 1. 패스워드 생성 법칙을 적용할 때

#### 상황

```
보안의 가장 기본은 아마도 패스워드 보안일 것.
그래서, 대부분의 시스템이나 웹 사이트에서는 복잡한 패스워드를 요구하는 곳이 많음.
리눅스 역시 생성되는 계정의 패스워드를 설정할 때
패스워드를 복잡하게 설정하여 외부로부터 침입하기 어려운 패스워드를 만들도록 설정할 수 있음.
이런 복잡한 패스워드 설정은 pam_pwquality라는 라이브러리에 의해 설정할 수 있음.
```



#### 방법 찾기

```
패스워드 생성 법칙은 pam_pwquality라는 라이브러리에 의해 설정되고 관리됨.
페도라 계열의 리눅스에서는 pam_pwquality라는 라이브러리가 기본적으로 탑재되어 있어 별도의 구성이 필요하지 않지만,
데비안 계열의 리눅스에서는 패스워드 생성 법칙을 적용하기 위해서 libpam-pwquality라는 패키지를 별도 설치해야 함.
```

- 필요한 정보
  - 페도라 계열의 리눅스 환경 설정파일 경로 : /etc/pam.d/system-auth
  - 데비안 계열의 리눅스 환경 설정파일 경로 : /etc/pam.d/common-password
  - 패스워드 생성 법칙 항목들과 의미
    - retry : 패스워드 입력 실패 시 재시도 횟수
    - minlen: 최소 패스워드 길이
    - difok : 이전 비밀번호와 유사한 문자 개수
    - lcredit : 소문자 최소 요구 개수
    - ucredit : 대문자 최소 요구 개수
    - dcredit : 숫자 최소 요구 개수
    - ocredit : 특수 문자 최소 요구 개수
    - enforce_for_root : root 사용자 패스워드 생성 법칙 적용
- 프로세스
  - 운영체제 타입 확인
  - 페도라 계열의 리눅스면 /etc/pam.d/system-auth 파일에 설정 적용
  - 데비안 계열의 리눅스라면 우선 /etc/pam.d/common-password 파일이 있는지 확인
  - 파일이 없으면 libpam-pwquality 패키지 설치
  - 파일이 있으면 /etc/pam.d/common-password에 설정 적용



#### 스크립트 생성

```sh
#!/bin/bash

# 운영체제 타입 확인
ostype=$(cat /etc/*release | grep ID_LIKE | sed "s/ID_LIKE=//;s\"//g")

# 운영체제가 페도라 계열일 경우
if [[ $ostype == "fedora" ]]
then
    # 설정 여부 체크
    conf_chk=$(cat /etc/pam.d/system-auth | grep 'local_users_only$' | wc -l)
    # 설정이 안되어 있으면 설정 후 설정 내용 확인
    if [ $conf_chk -eq 1 ]
    then
        # 소괄호로 묶어줌으로써 뒤에 오는 \1에 대한 우선 순위를 나타냄.
        # 이때 /\1은 local_users_only로 끝나는 라인의 바로 뒤에 오는 문자열을 붙여 쓰라는 듯.
        # 그래서, 셸 스크립트를 수행하고 나면 local_users_only로 끝나는 라인 뒤에 retry=3으로 시작하는 문자열들이 오게 됨.
        sed -i 's/\(local_users_only$\)/\1 retry=3 authtok_type= minlen=8 lcredit=-1 ucredit=-1 dcredit=-1 ocredit=-1 enforce_for_root/g' /etc/pam.d/system-auth

        # password로 시작하며 requisite 문자열 사이에 스페이스나 공백이 오는 문자열을 찾으라는 의미
        cat /etc/pam.d/system-auth | grep '^password[[:space:]]*requisite'
    fi

# 운영체제가 데비안 계열일 경우
elif [[ $ostype == "debian" ]]
then
    # pam_pwquality.so가 설치되어 있는지 설정파일을 통해 확인
    conf_chk=$(cat /etc/pam.d/common-password | grep 'pam_pwquality.so' | wc -l)

    # 설치가 안되어 있으면 libpam-pwquality 설치
    if [ $conf_chk -eq 0 ]
    then
        apt install libpam-pwquality
    fi

    # 설정 여부 체크
    conf_chk=$(cat /etc/pam.d/common-password | grep 'retry=3$' | wc -l)

    # 설정이 안되어 있으면 설정 후 설정 내용 확인
    if [ $conf_chk -eq 1 ]
    then
        sed -i 's/\(retry=3$\)/\1 minlen=8 maxrepeat=3 ucredit=-1 lcredit=-1 dcredit=-1 ocredit=-1 difok=3 gecoscheck=1 reject_username enforce_for_root/g' /etc/pam.d/common-password
        echo "========================================================"
        cat /etc/pam.d/common-password | grep '^password[[:space:]]*requisite'
    fi
fi
```

---



## 2. 패스워드 변경 주기를 설정할 때

#### 상황

```
리눅스 시스템 접근 계정의 패스워드를 3개월에 한번씩 변경하는 정책을 가져가는 회사가 많음.
```



#### 방법 찾기

- 필요한 정보
  - 패스워드 변경 주기 설정 명령어 : chage
  - 패스워드 변겅 주기 설정을 위한 옵션 및 의미
    - -d, --lastday LAST_DAY : 마지막으로 패스워드를 변경한 날짜 설정
    - -E, --expiredate EXPIRE_DATE : 특정 계정의 패스워드 만료일 설정
    - -I, --list : 패스워드 설정 주기 정보 확인
    - -m, --mindays MIN_DAYS : 패스워드 변경 최소 설정일
    - -M, --maxdays MAX_DAYS : 패스워드 변경 최대 설정일
    - -W, --warndays WARN_DAYS : 패스워드 만료 경고일
- 프로세스
  - 패스워드 설정 주기를 설정할 대상 서버 정보를 변수에 저장
  - 패스워드 설정 주기를 설정할 사용자 계정을 변수에 저장
  - for문을 돌면서 다음 프로세스 수행
    - 패스워드 설정 주기가 설정되어 있는지 chage -I 명령어를 이용해 확인
    - 설정되어 있지 않다면, 패스워드 설정 주기를 90일로 설정
    - 설정 정보 확인



#### 스크립트 생성

```sh
#!/bin/bash

# 대상 서버와 계정정보 변수 저장
hosts="host01 host02"
account="root stack user01 user02"

# 대상 서버만큼 반복
for host in $hosts; do
    echo "######## $host ########"
    # 계정정보만큼 반복
    for user in $account; do
        # 패스워드 설정 주기 체크
        # 패스워드 변경주기 항목 중 Maximum number로 시작하는 항목의 값이 변경 전에는 99999로 설정되어 있음
        # 따라서 grep을 이용하여 99999로 조회되면 아직 패스워드 설정 주기가 설정되지 않았다는 것을 알 수 있음
        pw_chk=$(ssh -q root@$host "chage -l $user | grep 99999 | wc -l")

        # 패스워드 설정 주기가 설정되어 있지 않다면
        if [[ $pw_chk -eq 1 ]]; then

            # -M 옵션을 사용하여 패스워드 설정 주기를 90일로 설정
            # 페도라 계열의 리눅스 같은 경우 패스워드를 설정한 적이 없다면
            # 마지막 패스워드 변경일을 함께 설정하지 않기 때문에
            # -d 옵션을 사용하여 설정일을 마지막 패스워드 변경일로 설정할 수 있음
            ssh -q root@$host "chage -d $(date +%Y-%m-%d) -M 90 $user"
            echo "========> $user"

            # 설정 결과 확인
            ssh -q root@$host "chage -l $user"

        fi
    done
done
```

---



## 3. 디렉터리 및 파일 접근 권한 변경할 때

#### 상황

```
리눅스에는 파일 소유자나 그룹 소유자만 해당 파일을 읽고, 쓰고, 삭제할 수 있는 권한을 줄 수 있음.
이런 권한을 Sticky bit이라 부르며, sticky bit이 파일이나 디렉터리 소유자에게 부여한 것은 SUID,
그룹 소유자에게 부여한 것을 SGID, 기타 사용자에게 부여한 것을 sticky bit이라 부름.
그런데, 이런 파일들은 특정 명령어를 실행하여 root 권한 획득 및 서비스의 장애를 발생시킬 수 있음.
따라서, 불필요한 파일에 SUID나 SGID, sticky bit이 설정되어 있지 않도록 관리해야 함.
또한, 모든 사용자가 접근 및 수정할 수 있는 권한을 가진 파일이 존재할 경우,
일반 사용자의 실수로 중요 파일 정보가 노출되거나 삭제되어 시스템 장애를 유발할 수 있음.
이런 파일을 World Writable 파일이라 부름. 따라서, 시스템을 구출할 경우나 운영할 경우
주기적으로 이런 디렉터리 및 파일 접근구너한을 모니터링하고 조치해야 함.
```



#### 방법 찾기

- 필요한 정보
  - SUID (Set User ID) 설정파일을 찾기 위한 명령어 : find / -perm -04000
  - SGID (Set Group ID) 설정파일을 찾기 위한 명령어 : find / -perm -02000
  - Sticky bit 설정파일을 찾기 위한 명령어 : find / -perm -01000
  - World Writable 파일 또는 디렉터리를 찾기 위한 명령어 : find / -xdev -perm -2
- 프로세스
  - SUID, SGID, sticky bit이 설정된 파일 및 디렉터리를 찾음
  - World Writable 디렉터리 및 파일을 찾음
  - 찾은 파일 목록을 보여주고, 권한 변경 여부를 물음
  - Y를 선택하면 sticky bit 파일은 644로 권한을 변경
  - World Writable 파일의 경우는 기타 사용자의 쓰기 권한을 제거
  - 모든 파일의 권한 변경이 완료되면 결과를 보여줌
  - N을 선택하면 스크립트를 그냥 종료
  - 엔터 키를 누르면 아무것도 입력하지 않았다는 메시지를 보여준 후 스크립트 종료
  - 이외에는 글자를 잘못 입력했다는 메시지를 보여준 후 스크립트 종료



#### 스크립트 생성

```sh
#!/bin/bash

# Sticky bit이 설정된 경로 검색
echo "===== SUID, SGID, sticky bit PATH ====="

# 퍼미션으로 인해 접근 불가능한 디렉터리와 같은 경우에는 에러 미시지를 출력하는데
# 2>/dev/null을 사용함으로써 에러 메시지는 보여주지 않음
# 검색된 파일이나 디렉터리 중 sticky bit을 가지면 안되는 주요 파일 경로를 grep을 이용하여 검색
s_file=$(find / -perm -04000 -o -perm -02000 -o -perm -01000 2>/dev/null | grep -e 'dump$' -e 'lp*-lpd$' -e 'newgrp$' -e 'restore$' -e 'at$' -e 'traceroute$')

# 명령엉 실행 결과를 xagrs ls -dl 명령어를 만나 다시 상세 파일 목록으로 조회
find / -perm -04000 -o -perm -02000 -o -perm -01000 2>/dev/null | grep -e 'dump$' -e 'lp*-lpd$' -e 'newgrp$' -e 'restore$' -e 'at$' -e 'traceroute$' | xargs ls -dl



# World Writable 경로 검색
echo -e "\n===== World Writable Path ====="

# -xdev를 사용하여 xfs 파일시스템 유형을 가진 파일이나 디렉터리만 검색하게 됨
# grep -v 'l..........' 명령어를 이용하여 l로 시작하는 심볼릭 링크를 검색에서 제외함.
# 나머지 검색 결과는 awk '{print $NF}' 명령어를 만나 마지막 필드값인 파일 경로만 추출하게 됨
# 추출하게 된 경로는 xargs ls -dl 명령어를 만나 다시 상세 파일 목록으로 조회
w_file=$(find / -xdev -perm -2 -ls | grep -v 'l..........' | awk '{print $NF}')
find / -xdev -perm -2 -ls | grep -v 'l..........' | awk '{print $NF}' | xargs ls -dl



# 검색된 파일들의 파일 권한 변경 여부 확인
echo ""
read -p "\nDo you want to change file permission(y/n)? " result

if [[ $result == "y" ]]; then
    
    # sticky bit 경로 권한 변경
    echo -e "\n===== chmod SUID, SGID, sticky bit Path ====="
    for file in $s_file; do
        echo "chmod -s $file"
        chmod -s $file
    done

    # Writable 경로 권한 변경
    echo -e "\n===== chmod World Writable Path ====="
    for file in $w_file; do
        echo "chmod o-w $file"
        chmod o-w $file
    done

    # sticky bit 경로 변경 결과 조회
    echo -e "\n===== Result of sticky bit Path ====="
    for file in $s_file; do
        ls -dl $file
    done

    # Writable 경로 변경 결과 조회
    echo -e "\n===== Result of World Writable Path ====="
    for file in $w_file; do
        ls -dl $file
    done

# 파일 권한 변경을 원하지 않을 경우
elif [[ $result == "n" ]]; then
    exit

# 파일 권한 변경 여부 질의에 아무것도 입력하지 않았을 경우
elif [[ -z $result ]]; then
    echo "You didn't have any choice. Please check these files for security."
    exit

# 파일 권한 변경 여부 질의에 아무 글자나 입력했을 경우
else
    echo "You can choose only y or n"
    exit

fi
```



#### 참고

> 파일시스템 유형

```
find 명령어 옵션 중 -xdev를 사용하면 xfs 이외의 파일시스템은 검색하지 않음.
그러나 -xdv 옵션을 사용하지 않으면 xfs 파일시스템 외에
proc, sysfs, debugfs, cgroup, tmpfs, mqueue와 같은 파일세스템 유형을 가진 파일 경로까지 모두 검색함.
일반적인 파일 속성을 확인하는 file이나 stat과 같은 명령어에서 이런 파일시스템 유형을 확인할 수 없음.
하지만 find의 printf와 같은 액션을 사용하는 경우 파일시스템 유형을 출력해주는 %F 포맷이 있음.
이를 통해 파일시스템 유형을 확인할 수 있음.
```

- proc : 커널 프로세스를 포함하는 실행 중인 프로세스들을 위한 디렉터리 및 파일 유형
- sysfs : 리눅스 커널이 제공하는 가상 파일시스템을 위한 디렉터리 및 파일 유형
- debugfs : 파일시스템을 디버깅하기 위한 파일 및 디렉터리 유형
- cgroup : 컨테이너 기술에 사용되며, 프로세스들이 사용하는 컴퓨팅 자원을 제한하고 격리
- tmpfs : 메모리를 디스크처럼 쓸 수 있는 파일시스템
- mqueue : 시스템의 메시지 큐를 읽기 위한 파일시스템
- xfs : 고성능 64bit 저널링 파일시스템

---



## 4. Firewall에 포트 추가할 때

#### 상황

```
리눅스에는 자체적으로 외부로부터의 침입을 방지하기 위해 iptables나 firewalld와 같은
방화벽 서비스를 사용하여 서버에서 허용한 특정 포트 이외에는 들어오지 못하도록 설정함.
그래서, 애플리케이션을 설치할 때마다 해당 애플리케이션이 사용하는 포트를 iptables나 firewalld에 추가해야 함.
물론 한두 개의 포트를 추가할 경우에는 상관이 없지만,
여러 개의 포트를 추가할 경우에는 생각보다 꽤 많은 시간이 소요됨.
```



#### 방법 찾기

```
레드햇이나 CentOS 리눅스와 같은 경우에는 이전 6 버전 때에는 iptables를 기본 방화벽으로 사용하다가
7 버전으로 오면서 firewalld가 기본 방화벽으로 변경되었음.
우분투와 같은 데비안 계열의 리눅스의 경우에는 iptables 대신 ufw라는 방화벽을 사용.
```

- 필요한 정보
  - firewalld에서 서비스 포트 추가 명령어 : firewall-cmd --add-service=[service name]
  - firewalld에서 포트 추가 명령어 : firewall-cmd --add-pot=[port/protocol]
  - ufw에서 서비스 포트 추가 명령어 : uf allow [service name | port/protocol]
- 프로세스
  - 운영체제 타입이 페도라 계열인지 데비안 계열인지 확인
  - 운영체제가 페도라 계열이면 시스템에 firewalld가 실행 중인지 확인
  - 운영체제가 데비안 계열이면 시스템에 ufw가 실행 중인지 확인
  - 사용자로부터 추가할 포트 목록을 입력받음.
  - 운영체제가 페도라 계열이면 firewall -cmd 명령어를 이용하여 포트 추가
  - 운영체제가 데비안 계열이면 ufw 명령어를 이용하여 포트 추가



#### 스크립트 생성

```sh
#!/bin/bash

# 운영체제 타입 확인
ostype=$(cat /etc/*release | grep ID_LIKE | sed "s/ID_LIKE=//;s/\"//g")

read -p "Please input ports(ex: http 123/tcp 123/udp): " ports

if [[ -z $ports ]]; then echo "You didn't input port. Please retry."; exit; fi

# 운영체제가 페도라 계열일 경우
if [[ $ostype == "fedora" ]]; then
    # firewalld 실행 상태 체크
    run_chk=$(firewall-cmd --state)
    if [[ $run_chk == "running" ]]; then
        # 입력받은 port만큼 반복
        for port in $ports; do
            # service port인지, 일반 port인지 체크
            # 페도라 리눅스 계열의 firewalld는 이미 잘 알려진 서비스 포트 같은 경우에는
            # 서비스명을 입력하면 해당 포트를 추가할 수 있음
            # 문자열로 된 서비스 포트를 추가할 경우에는 --add-service라는 옵션 사용
            # 숫자로 된 포트를 추가할 경우에는 --add-port 옵션을 사용하여 추가.
            chk_port=$(echo $port | grep '^[a-zA-Z]' | wc -l)
            # service port일 경우
            if [[ chk_port -eq 1 ]]; then
                firewall-cmd --add-service=$port
                firewall-cmd --add-service=$port --permanent
            # 일반 port일 경우
            else
                firewall-cmd --add-port=$port
                firewall-cmd --add-port=$port --permanent
            fi
        done
    else
        echo "firewall is not running"
        exit
    fi

# 운영체제가 데비안 계열일 경우
elif [[ $ostype == "debian" ]]; then
    # ufw 실행 상태 체크
    run_chk=$(ufw status | grep ": active" | wc -l)
    if [[ $run_chk -eq 1 ]]; then
        # 입력받은 port만큼 반복
        for port in $ports; do
            ufw allow $port
        done
        # port 추가 결과 확인
        ufw status
    else
        echo "ufw is not running"
        exit
    fi
fi
```

---



## 5. 사설 인증서 생성할 때

#### 상황

```
개발을 하다보면 http 보안을 위해 공인 인증서를 발급받아 사용하거나 사설 인증서를 생성하여 사용.
공인 인증서는 주로 서비스를 할 때 발급받아 사용하며,
그 외에 내부 서비스나 개별용으로는 사설 인증서를 주로 생성하여 사용.
그런데 사설 인증서를 생성하는 과정과 명령어가 매우 복잡함.
그래서 사설 인증서를 생성할 때마다 어떤 순서로 어떤 명령어를 써야할지 몰라서 한참 헤매기도 함.
이때 사설 인증서 생성과정을 잘 스크립트화 해 놓는다면 굳이 스크립트를 실행하지 않더라도
어떤 명령어를 사용하였는지 참고할 수 있고, 스크립트를 사용하면 좀 더 쉽게 사설 인증서를 생성할 수 있음.
```

#### 방법 찾기

```
사설 인증서를 생성할 때는 주로 openssl 명령어를 이용하여 인증기관용 인증서와 클라이언트용 인증서를 생성함.
```

- 필요한 정보
  - RSA 개인 키 생성 명령어 : openssl genrsa
  - 자체 서명된 root CA 인증서 생성 명령어 : openssl req
  - 자체 CA 인증서와 클라이언트키를 이용하여 클라이언트 인증키 생성 명령어 : openssl ca
  - 명령어별 상세 옵션 설명 확인 : man genrsa, man req, man ca
- 프로세스
  - 자체 서명된 root CA 인증서가 생성될 디렉터리 생성
  - CA 디렉터리에 빈 index.txt와 1000이 입력된 serial 생성
  - 인증 기관용 개인 키와 인증서 생성
  - 클라이언트에 인증기관용 인증서 추가
  - 추가한 인증서가 믿을 수 있는 인증서라고 설정
  - 서버에서 사용할 SSL/TLS 서버 키 만듬
  - 서버에서 사용할 인증요청서 만듬
  - 서버의 인증요청서를 이용하여 CA에서 인증서를 발급받음



#### 스크립트 생성

```
사설인증서 생성은 암호화 알고리즘이라는 복잡한 용어들이 많이 사용되어 이해하기도 쉽지 않고,
명령어에 사용되는 옵션들도 많아 늘 생성할 때마다 매뉴얼을 찾아보거나 인터넷 검색을 해야 함.
```

###### 페도라 계열 스크립트

```sh
#!/bin/bash

# 서명용 호스트 초기화
echo "==============================================="
echo "          Initializing signing host            "
echo "==============================================="

# 레드햇 리눅스에는 일반적으로 /etc/pki/CA 디렉터리가 존재함.
# 해당 디렉터리에 index.txt 파일을 생성하고
# serial 1000이라는 숫자를 입력하여 파일을 생성
# 이는 마지막에 인증서를 생성할 때 index.txt에 발행한 인증서 정보를 저장하고
# serial에 발급된 인증서 수를 등록하기 위함임
touch /etc/pki/CA/index.txt
echo '1000' | tee /etc/pki/CA/serial

# 인증 기관용 인증서 생성
echo "==============================================="
echo "      Creating a certificate authority         "
echo "==============================================="

echo "-----------------------------------------------"
echo "            Generate rsa ca key                "
echo "-----------------------------------------------"

# RSA 개인 키를 생성함
# 이때 키는 -out 옵션 다음에 오는 ca.key.pem 파일에 저장되고
# 4096은 생성되는 키의 사이즈를 말함
# 가장 기본적인 방법으로 키를 생성하였지만
# 다른 옵션(-aes256, -camellia256, --des3과 같은 옵션)을 사용하여 생성되는 키의 암호화 방식을 설정할 수 있음.
# 개인 키가 생성되면 openssl req 명령어를 이용하여 앞에서 생성한 키를 이용하여 인증 기관용 인증요청서를 생성함.
openssl genrsa -out ca.key.pem 4096

echo "-----------------------------------------------"
echo "          Generate rsa ca cert key             "
echo "-----------------------------------------------"
openssl req -key ca.key.pem -new -x509 -days 7300 -extensions v3_ca -out ca.crt.pem

# 클라이언트에 인증기관용 인증서 추가
echo "==============================================="
echo "  Adding the certificate authority to clients  "
echo "==============================================="
echo "cp ca.crt.pem /etc/pki/ca-trust/source/anchors/"
cp ca.crt.pem /etc/pki/ca-trust/source/anchors/

# 자기 스스로 인증한 인증서이므로
# 앞에서 생성한 인증요청서를 /etc/pki/ca-trust/source/anchors/ 디렉터리에 복사하고
# update-ca-trust extract 명령어를 이용하여 믿을 수 있는 인증서라고 시스템이 인식할 수 있도록 만들어 줌
echo "update-ca-trust extract"
update-ca-trust extract

# SSL/TLS 서버 키 생성
echo "==============================================="
echo "          Creating an SSL/TLS key              "
echo "==============================================="

# 클라이언트에서 사용할 SSL/TLS를 위한 서버 키를 CA 개인 키를 만들 때처럼
# openssl genrsa 명령어를 이용하여 서버 개인 키를 만들어 줌
# /etc/pki/tls/openssl.cnf를 인증서 생성 디렉터리에 복사
# 원래는 복사 후 cnf 파일을 사용하기 편리하게 수정하지만 생략
openssl genrsa -out server.key.pem 2048

# SSL/TLS 인증요청서 생성
echo "==============================================="
echo "Creating an SSL/TLS certificate signing request"
echo "==============================================="
cp /etc/pki/tls/openssl.cnf .
openssl req -config openssl.cnf -key server.key.pem -new -out server.csr.pem

# SSL/TLS 인증서 생성
echo "==============================================="
echo "      Creating the SSL/TLS certificate         "
echo "==============================================="

# 앞에서 생성한 서버용 인증요청서와 인증기관용 개인 키 및 인증요청서를 가지고 인증서를 발급받음
# 발급받는 인증서는 -out 옵션을 이용하여 server.crt.pem 파일에 저장
openssl ca -config openssl.cnf -extensions v3_req -days 3650 -in server.csr.pem -out server.crt.pem -cert ca.crt.pem -keyfile ca.key.pem
```



###### 우분투 스크립트

```sh
#!/bin/bash

# 서명용 호스트 초기화
echo "==============================================="
echo "          Initializing signing host            "
echo "==============================================="
mkdir -p ./demoCA/certs ./demoCA/crl ./demoCA/newcerts ./demoCA/private
touch ./demoCA/index.txt
echo '1000' | tee ./demoCA/serial

# 인증 기관용 인증서 생성
echo "==============================================="
echo "      Creating a certificate authority         "
echo "==============================================="

echo "-----------------------------------------------"
echo "            Generate rsa ca key                "
echo "-----------------------------------------------"
openssl genrsa -out ca.key.pem 4096

echo "-----------------------------------------------"
echo "          Generate rsa ca cert key             "
echo "-----------------------------------------------"
openssl req -key ca.key.pem -new -x509 -days 7300 -extensions v3_ca -out ca.crt.pem

# 클라이언트에 인증기관용 인증서 추가
echo "==============================================="
echo "  Adding the certificate authority to clients  "
echo "==============================================="

# 우분투 리눅스에서는 /usr/local/share/ca-certificates 디렉터리에
# 자체 CA 인증요청서를 복사하고
# update-ca-certificates 명령어를 이용하여 믿을 수 있는 인증서라고 시스템이 인식할 수 있도록 함
echo "cp ca.crt.pem /usr/local/share/ca-certificates/"
cp ca.crt.pem /usr/local/share/ca-certificates/

echo "update-ca-certificates"
update-ca-certificates

# SSL/TLS 서버 키 생성
echo "==============================================="
echo "          Creating an SSL/TLS key              "
echo "==============================================="
openssl genrsa -out server.key.pem 2048

# SSL/TLS 인증요청서 생성
echo "==============================================="
echo "Creating an SSL/TLS certificate signing request"
echo "==============================================="
cp /usr/lib/ssl/openssl.cnf .
openssl req -config openssl.cnf -key server.key.pem -new -out server.csr.pem

# SSL/TLS 인증서 생성
echo "==============================================="
echo "      Creating the SSL/TLS certificate         "
echo "==============================================="
openssl ca -config openssl.cnf -extensions v3_req -days 3650 -in server.csr.pem -out server.crt.pem -cert ca.crt.pem -keyfile ca.key.pem
```

