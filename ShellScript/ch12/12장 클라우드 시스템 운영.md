# 12장 클라우드 시스템 운영

```
근래에는 베어메탈 환경을 그대로 운영하는 곳도 있지만,
대부분의 회사들이 클라우드 시스템을 사용하거나 클라우드 시스템 환경을 구축하고, 클라우드 서비스를 제공하는 곳도 많이 있음.
뿐만 아니라, 개발 환경 역시 베어메탈 환경에서 가상 환경으로 그리고 컨테이너 환경으로 많이 넘어가고 있는 상황.
```

## 1. VM 백업할 때

#### 상황

```
오픈스택을 설치하고 운영하기 위해서는 오픈스택이 설치된 서버 이외에 필요한 시스템들이 많음.
이런 시스템을 구축하기 위해 별도의 서버에 VM을 생성하여 주로 사용함.
이러한 시스템은 주로 오픈스택을 배포하기 위한 배포 노드나 패키지 등을 저장하기 위해
리포지터리 서버, 백업을 위한 백업 서버 등이 해당됨.
이렇게 VM으로 구성된 서버의 운영체제 업데이트와 같은 작업을 할 경우나 시스템의 중요한 작업 등을 할 경우에
VM을 백업하고 작업하는 것이 좋음.
```



#### 방법 찾기

```
VM을 백업하기 위해서는 백업을 할 별도의 스토리지가 필요함.
일반적으로는 운영체제와 분리된 디스크에 저장하거나, 별도의 NFS에 저장함.
```

- 필요한 정보
  - VM을 백업받을 NFS 정보
  - 백업받을 VM 정보
  - VM이 생성되어 있는 디렉터리 정보
- 프로세스
  - 현재 시스템에서 존재하는 VM 정보를 보여줌
  - 백업받을 VM명을 입력받음
  - 백업받은 VM 상태가 shutdown인지 확인
  - shutdown이 아니라면 shutdown할 것인지 물어봄
  - VM을 백업받을 NFS에 마운트되어 있는지 확인
  - 마운트되어 있지 않다면 디렉터리를 생성하고, 해당 디렉터리에 NFS를 마운트함
  - 마운트된 디렉터리에 실행 날짜로 백업 디렉터리를 생성함
  - 해당 백업 디렉터리에 VM을 tar 압축하여 백업함
  - 백업이 끝나면 해당 VM을 다시 시작함
  - 마지막으로 NFS를 언마운트 함



#### 스크립트 생성

> libvirt-clients 필요

```sh
#!/bin/bash

NFS_PATH="192.168.100.10:/osp16_backup"
MOUNT_PATH=/tmp/backup

# VM 목록 확인
virsh list --all

# 백업할 VM명 확인
read -p "Input vm name for backup : " vmname

# 입력받은 VM 상태 확인
vmstat=$(virsh list --all | grep -e $vmname -e "shut off" | wc -l)

# VM 상태가 running일 경우
if [[ $vmstat -eq 0 ]]; then
    # VM을 shut off할지 여부 확인
    read -p "$vmname is running. Do you want to shut off? (y/n) " vmresult
    if [[ $vmresult == "y" ]]; then
        echo "$vmname will be shut off soon"
        virsh shutdown $vmname
        echo "Please retry to run this script."
        exit
    else
        exit
    fi
else
    echo "==============================="
    echo "      Make Mount Directory     "
    echo "==============================="
    mkdir -p $MOUNT_PATH

    echo "==============================="
    echo "     Make Directory to NFS     "
    echo "==============================="
    mount -t nfs $NFS_PATH $MOUNT_PATH

    echo "==============================="
    echo "     Make Backup Directory     "
    echo "==============================="
    backup_path=$MOUNT_PATH/backup_$(date +%Y%M%d)
    mkdir -p $backup_path

    echo "==============================="
    echo "      Find vm file path        "
    echo "==============================="
    file_path=$(virsh dumpxml $vmname | grep 'source file' | sed "s/[[:blank:]]*<source file='//g" | sed "s/'\/>//g")

    echo "==============================="
    echo "       Backup vm file          "
    echo "==============================="
    cp $file_path $backup_path
    if [[ -f $backup_path/$file_path ]]; then
        echo "==============================="
        echo "  Finish backup and start vm   "
        echo "==============================="
        virsh start $vmname

        echo "==============================="
        echo "         Unmount NFS           "
        echo "==============================="
        umount $MOUNT_PATH
    fi
fi
```

---



## 2. 컨테이너화된 오픈스택 서비스 운영할 때

#### 상황

```
근래에 설치되는 오픈스택 서비스는 이전과는 다르게 패키지 기반의 서비스가 아닌 컨테이너 기반의 서비스로 설치됨.
따라서, 컨테이너가 잘 동작을 하는지, 컨테이너 서비스에 문제는 없는지, 명령어는 잘 동작하는지를 확인할 경우에도
스크립트를 사용하면 매우 효율적이고 빠르게 서비스 상태를 확인할 수 있음.
```



#### 방법 찾기

```
오픈스택 서비스 역시 버전에 따라 그리고 어떤 방법과 어떤 환경으로 구축했느냐에 따라서 확인해야 할 서비스 종류가 달라짐.
```

- 필요한 정보
  - 컨트롤러 노드에서 실행 중인 컨테이너 서비스 개수
  - 컴퓨트 노드에서 실행 중인 컨테이너 서비스 개수
  - 컨트롤러 노드의 오픈스택 컨테이너 로그 디렉터리 : /var/log/containers
  - 컴퓨트 노드의 오픈스택 컨테이너 로그 디렉터리 : /var/log/containers
  - 컴퓨트 서비스 실행 여부 확인 명령어 : openstack compute service list
  - 볼륨 서비스 실행 여부 확인 명령어 : openstack volume service list
  - 네트워크 서비스 실행 여부 확인 명령어 : openstack network agent list
- 프로세스
  - 컨트롤러 노드에서 실행 중인 컨테이너 개수를 사전에 조사하여 변수에 저장
  - 컴퓨트 노드에서 실행 중인 컨테이너 개수를 사전에 조사하여 변수에 저장
  - 접속하고자 하는 컨트롤러 노드의 호스트명과 컴퓨트 노드의 호스트명을 변수에 저장
  - for문을 돌면서 컨트롤러 노드에서 실행 중인 컨테이너 개수를 확인
  - for문을 돌면서 컴퓨트 노드에서 실행 중인 컨테이너 개수를 확인
  - 사전에 조사한 컨테이너 개수와 확인된 컨테이너 개수가 맞지 않으면 경고 메시지 출력
  - 컨트롤러 노드의 컨테이너 로그에서 ERROR가 있는지 확인
  - 컴퓨트 노드의 컨테이너 로그에서 ERROR가 있는지 확인
  - ERROR가 있으면 경고 메시지 출력
  - 명령어를 이용하여 컴퓨트 서비스 실행 여부와 볼륨 서비스 실행 여부, 네트워크 서비스 실행 여부를 확인



#### 스크립트 생성

```sh
#!/bin/bash

CON_CNT=34
COM_CNT=8
CON_HOSTS="ctrl1 ctrl2 ctrl3"
COM_HOSTS="com1 com2 com3 com4"

# 컨트롤러 노드 컨테이너 상태 및 서비스 로그 확인
for host in $CON_HOSTS; do
    echo "============== $host =============="
    echo ">>>>> Check containers status <<<<<"
    
    # -v : 헤더 삭제
    cnt=$(ssh heat-admin@$host "sudo docker ps | grep -v IMAGE | wc -l")
    if [[ $cnt -eq $CON_CNT ]]; then
        echo "The $host containers count is $cnt. This is normal."
    else
        echo "Please check containers status."
        ssh heat-admin@$host "sudo docker ps"
    fi

    echo ">>>>> Check service logs <<<<<"
    ssh heat-admin@$host "echo 'tail /var/log/containers/*/*.log | grep -i error | wc -l' > mon-logs.sh"
    err_cnt=$(ssh heat-admin@$host "sudo sh mon-logs.sh")
    if [[ $err_cnt -eq 0 ]]; then
        echo "The $host has no error logs. This system is normal."
    else
        echo "Please check service logs."
        ssh heat-admin@$host "echo 'tail /var/log/containers/*/*.log | grep -i error > mon-logs.sh"
        ssh heat-admin@$host "sudo sh mon-logs.sh"
    fi
done

# 컴퓨트 노드 컨테이너 상태 및 서비스 로그 확인
for host in $COM_HOSTS; do
    echo "============== $host =============="
    echo ">>>>> Check containers status <<<<<"
    cnt=$(ssh heat-admin@$host "sudo docker ps | grep -v IMAGE | wc -l")
    if [[ $cnt -eq $COM_CNT ]]; then
        echo "The $host containers count is $cnt. This is normal."
    else
        echo "Please check containers status"
        ssh head-admin@$host "sudo docker ps"
    fi

    echo ">>>>> Check service logs <<<<<"
    ssh heat-admin@$host "echo 'tail /var/log/containers/*/*.log | grep -i error | wc -l' > mon-logs.sh"
    err_cnt=$(ssh heat-admin@$host "sudo sh mon-logs.sh")
    if [[ $err_cnt -eq 0 ]]; then
        echo "The $host has no error logs. This system is normal."
    else
        echo "Please check service logs."
        ssh heat-admin@$host "echo 'tail /var/log/containers/*/*.log | grep -i error' > mon-logs.sh"
        ssh heat-admin@$host "sudo sh mon-logs.sh"
    fi
done

echo "==============================="
echo "    Check Openstack Services   "
echo "==============================="
# 서비스 확인
source /home/stack/adminrc

# 컴퓨트 서비스 확인
echo "openstack compute service list"
openstack compute service list
# 볼륨 서비스 확인
echo "openstack volume service list"
openstack volume service list
# 네트워크 서비스 확인
echo "openstack network agent list"
openstack network agent list
```

---



## 3. CLI를 이용해 오픈스택 이미지 업로드할 때

#### 상황

```
오픈스택 운영을 하다보면 인스턴스 생성에 필요한 이미지를 업로드해야 할 경우가 종종 발생함.
이미지 사이즈가 크지 않을 경우에는 오픈스택 대시보드를 이용하여 이미지를 업로드할 수 있지만,
이미지 사이즈가 큰 경우에는 명령어를 이용하여 이미지를 업로드해야 함.
이때 오픈스택 명령어를 이용하면 이미지를 업로드하기 위해 여러 옵션들을 사용해야 함.
```



#### 방법 찾기

- 필요한 정보
  - 오픈스택 명령어 사용을 위한 인증 파일
  - 오픈스택 이미지 업로드 명령어 : openstack image create
  - 오픈스택 이미지 경로 및 이미지명
- 프로세스
  - Source 명령어를 이용하여 명령어 사용을 위한 인증 파일을 export 함
  - 업로드할 이미지의 파일 경로를 입력받음
  - 파일 경로가 맞는지 확인하고, 맞지 않으면 에러 메시지를 출력함.
  - 파일 경로를 확인하여 파일명만 변수에 별도로 저장
  - 파일 확장자를 확인하여 변수에 확장자명만 별도로 지정
  - 오픈스택 명령어를 이용하여 해당 파일을 업로드



#### 스크립트

```sh
#!/bin/bash

read -p "Please input image path : " imgpath

if [[ -f $imgpath ]]; then
    read -p "Please input image name : " imgname
    # 인증 파일 export
    source ~/adminrc
    openstack image create \
    --file $imgpath \
    --container-format bare \
    --disk-format $(ls $imgpath | awk -F . '$NF == "qcow2" ? type="qcow2" : type="raw" {print type}') \
    --public \
    $imgname
else
    echo "This is no image. Please try to run the script again."
    exit
fi
```

---



## 4. CLI를 이용해 오픈스택 flavor 생성할 때

#### 상황

```
flavor는 인스턴스를 생성할 때 필요한 인스턴스의 사양이라고 생각하면 됨.
예를 들어 VM을 생성할 때 필요한 CPU의 개수, Memory 사이즈 또는 디스크 사이즈와 같은 것들을 미리 정의해 놓은 것.
오픈스택이 구성되면 가장 처음으로 하는 일이 바로 flavor를 만드는 일.
대시보드를 통해 flavor를 생성할 수도 있지만, 명령어를 이용하여 flavor를 생성할 수도 있음.
```



#### 방법 찾기

- 필요한 정보
  - 오픈스택 명령어 사용을 위한 인증 파일 경로
  - flavor를 생성하기 위한 명령어 : openstack flavor create
  - flavor 생성 확인을 위한 명령어 : openstack flavor list
  - flavor를 생성하기 위한 파라미터 정보들 : vcpu, 메모리, 디스크 사이즈 등
- 프로세스
  - 사용자는 flavor를 하나만 생성할 수도 있고, 여러 개를 한번에 생성할 수도 있음
  - 하나만 생성할 경우 사용자로부터 생성하고자 하는 flavor 정보를 입력받음
  - flavor 정보는 flavor 이름, vcpu 개수, 메모리 사이즈, 디스크 사이즈 등을 입력받음
  - 인증서를 export함
  - 오픈스택 명령어를 이용하여 flavor 생성
  - 여러 개를 생성할 경우 flavor 정보가 저장된 파일 경로를 입력받음
  - 파일 경로가 정상인지 확인
  - 파일 내용을 한줄씩 읽어 오픈스택 명령어를 이용하여 flavor를 생성
  - 파일 경로가 잘못되었다면 에러 메시지 출력 후 스크립트 종료



#### 스크립트 생성

```sh
#!/bin/bash

# flavor 하나만 생성할 경우
if [[ $1 == "" ]]; then
    read -p "Flavor name : " flname
    read -p "Number of VCPUs : " vcpus
    read -p "Memory size in MB : " rams
    read -p "Disk size in GB : " disks
    read -p "Ephemeral disk size in GB : " edisks

    # 인증 정보 export
    source ~/adminrc

    # CLI를 이용한 flavor 생성
    openstack flavor create \
    --vcpus $vcpus \
    --ram $rams \
    --disk $disks \
    --ephemeral $edisks \
    --public \
    $flname

# 여러개 생성할 경우
else
    if [[ -f $1 ]]; then
        # while read line; do ~ done < $1을 이용하여 한줄 한줄 읽어 들임
        # 여기서 line은 읽어 들인 해당 라인 내용을 저장할 변수명이며
        # done 다음에 나오는 $1은 파라미터로 받은 파일 경로
        while read line; do
            soruce ~/adminrc

            echo "Creating flavor $(echo $line | awk '{print $1}')"
            openstack flavor create \
            --vcpus $(echo $line | awk '{print $2}') \
            --ram $(echo $line | awk '{print $3}') \
            --disk $(echo $line | awk '{print $4}') \
            --ephemeral $(echo $line | awk '{print $5}') \
            --public \
            $(echo $line | awk '{print $1}')
        done < $1
    else
        echo "This is no file. Please try to run this script again."
        exit
    fi
fi
```

---



## 5. CLI를 이용해 오픈스택 인스턴스 마이그레이션할 때

#### 상황

```
오픈스택을 운영하다 보면 시스템 업데이트 작업으로 인해 시스템을 재부팅해야 하는 경우가 발생하고 함.
이런 경우에는 해당 시스템의 인스턴스를 다른 시스템으로 마이그레이션한 후 재부팅해야 함.
이때 대시보드를 통해 마이그레이션을 할 수도 있지만,
오픈스택 명령어와 스크립트를 이용해 특정 시스템의 인스턴스들을 다른 시스템으로 쉽게 마이그레이션할 수 있음.
```



#### 방법 찾기

- 필요한 정보
  - 오픈스택 명령어를 사용을 위한 인증 파일 경로
  - 컴퓨트 노드 목록 확인 명령어 : openstack compute service list
  - 인스턴스 목록 확인 명령어 : openstack server list
  - 인스턴스 마이그레이션 명령어 : openstack server migrate
- 프로세스
  - 인스턴스를 마이그레이션하고자 하는 컴퓨트 노드명을 입력받음
  - 인스턴스가 마이그레이션될 컴퓨트 노드명을 입력받음
  - 오픈스택 명령어를 사용하기 위한 인증서를 export
  - 오픈스택 명령어를 이용하여 인스턴스 마이그레이션 명령어를 생성
  - 생성된 명령어는 리다이렉션 기호를 이용하여 다른 파일에 저장



#### 스크립트 생성

```sh
#!/bin/bash

source ~/adminrc

# 원 호스트명과 대상 호스트명 파라미터 저장
HNAME=$1
TNAME=$2

if [[ -n "$HNAME" ]] && [[ -N "$TNAME" ]]; then
    # 원 호스트명 조회 및 추출
    SHOST=$(openstack compute service list -c binary -c host -f value | grep compute | grep "$HNAME" | awk '{print $2}')
    
    # 대상 호스트명 조회 및 추출
    DHOST=$(openstack compute service list -c binary -c host -f value | grep compute | grep "$TNAME" | awk '{print $2}')
    echo "This script will make a script about $SHOST instance migrate to $DHOST"

    # 오픈스택 명령어를 이용한 인스턴스 마이그레이션 명령 생성
    # -v 옵션을 이용해 t라는 변수에 저장
    # print 명령어를 이용하여 앞에서 조회한 인스턴스 ID와 오픈스택 마이그레이션 명령어를 조합하여 출력
    # 해당 결과는 > 리다이렉션 기호를 이용하여 vm_migrate_$HNAME.sh에 저장
    openstack server list --host $SHOST --all-projects -c ID -f value | awk -v t=$DHOST '{print "openstack server migrate "$1" --live-migration --host "t" --wait"}' > ~/vm_migrate_$HNAME.sh

    echo "Make the script finish. you can see /home/stack/vm_migrate_$HNAME.sh"
else
    echo "Please input source and target hostnames."
    echo "ex) sh migrate_vm_command.sh com01 com02"
fi
```

---



## 6. CLI를 이용해 오픈스택 인스턴스의 전원을 끌 때

#### 상황

```
오픈스택을 구축하고, 사용하다 보면 때로는 오픈스택의 모든 인스턴스 전원을 꺼야 할 경우가 생김.
또는 특정 컴퓨트 노드에서 실행 중인 인스턴스의 전원을 꺼야 할 경우도 발생함.
인스턴스가 한두 개라면 상관 없지만, 많은 수의 인스턴스의 전원을 꺼야 할 경우에는 많은 시간이 소요됨.
```



#### 방법 찾기

- 필요한 정보
  - 오픈스택 명령어 사용을 위한 인증 파일 경로
  - 컴퓨트 노드 목록 확인 명령어 : openstack compute service list
  - 인스턴스 목록 확인 명령어 : oepnstack server list
  - 인스턴스 전원 종료 명령어 : openstack server stop
- 프로세스
  - 인스턴스의 전원을 끌 대상 컴퓨트 노드 정보를 파라미터로 입력받음
  - 컴퓨트명의 full name 조회
  - 해당 호스트의 인스턴스를 조회하여 전원 종료를 위한 명령어를 생성하고, 파일로 저장



#### 스크립트 생성

```sh
#!/bin/bash

source ~/adminrc

if [[ -n "$1" ]]; then
    SHOST=$(openstack compute service list -c Binary -c Host -f value | grep compute | grep "$1" | awk '{print $2}')

    echo "This script will make a script about $SHOST instance power off."

    oepnstack server list --host $SHOST --all-projects -c ID -f value | awk '{print "openstack server stop "$1}' > /home/stack/vm_poweroff_$1.sh
else
    echo "Please input hostname."
    echo "ex) sh vm-poweroff.sh com01"
fi
```

---



## 7. CLI를 이용해 오픈스택 인스턴스 시작할 때

#### 상황

```
인스턴스를 종료할 일이 있다면 당연히 인스턴스를 시작할 일도 있음.
특히 오픈스택을 구축하고, 테스트할 경우 여러 개의 인스턴스를 생성하고,
전원을 끄거나 다시 시작하거나, 삭제하는 등의 기능 테스트를 함.
```



#### 방법 찾기

- 필요한 정보
  - 오픈스택 명령어 사용을 위한 인증 파일 경로
  - 컴퓨트 노드 목록 확인 명령어 : openstack compute service list
  - 인스턴스 목록 확인 명령어 : openstack server list
  - 인스턴스 시작 명령어 : oepnstack server start
- 프로세스
  - 인스턴스를 시작할 대상 컴퓨트 노드 정보를 파라미터로 입력받음
  - 컴퓨트명의 full name 조회
  - 해당 호스트의 인스턴스를 조회하여 인스턴스 시작 명령어를 생성하고 파일로 저장



#### 스크립트 생성

```sh
#!/bin/bash

source ~/adminrc

if [[ -n "$1" ]]; then
    SHOST=$(openstack compute service list -c Binary -c Host -f value | grep compute | grep "$1" | awk '{print $2}')

    echo "This script will make a script about $SHOST instance start."

    openstack server list --host $SHOST --all-projects -c ID -f value | awk '{print "openstack server start "$1}' > ~/vm_start_$1.sh
else
    echo "Please input hostname."
    echo "ex) sh vm-start.sh com01"
fi
```

---



## 8. CLI를 이용해 오픈스택 인스턴스 삭제할 때

#### 상황

```
오픈스택을 구축하고 기능 테스트가 끝나면 이제 모든 인스턴스를 삭제해야 함.
```



#### 방법 찾기

- 필요한 정보
  - 오픈스택 명령어 사용을 위한 인증 파일 경로
  - 인스턴스 목록 확인 명령어 : openstack server list
  - 인스턴스 삭제 명령어 : openstack server delete
- 프로세스
  - 오픈스택 명령어 사용 위해 인증 파일 export
  - 인스턴스 목록을 조회하여 인스턴스 삭제 명령어를 생성하고 파일로 저장



#### 스크립트 생성

```sh
#!/bin/bash

source ~/adminrc

echo "This script will make a script about instance delete."

openstack server list --all-projects -c ID -f value | awk '{print "openstack server delete "$1}' > ~/vm_delete.sh
```

