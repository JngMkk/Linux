# 9장 환경 설정

```
서버에 운영체제를 설치하고, 다양한 애플리케이션들을 설치하다 보면,
해당 애플리케이션이나 시스템에 환경 설정을 해야 하는 상황이 발생함.
예를 들어 클러스터된 서비스를 구축한다고 하면,
클러스터 간에 ssh를 통해 패스워드 없이 ssh-key로 접속할 수 딨도록 설정해야 할 수도 있고,
클러스터 간 시간 동기화를 위해 NTP 설정을 해야 하는 경우도 있음.
때로는 개발 서버 간 소스를 공유하기 위해 NFS 스토리지에 마운트를 해야 하는 상황도 발생함.
```



## 1. sshd 환경 설정 변경할 때

#### 상황

```
대부분의 회사에 구축되는 리눅스 시스템은 보안을 위해 접근 제한을 하기도 하고,
SSH 기본 포트인 22번 포트를 다른 포트로 변경하기도 함.
서버가 한두 대라면 상관이 없지만, 여러 대의 서버에 적용해야 한다거나,
시스템의 SSH 설정을 확인하고 조치까지 취해야 한다면 셸스크립트가 매우 도움이 됨.
```



#### 방법 찾기

```
SSH에서 가장 설정 변경을 많이 하는 항목들을 알아보고, 해당 항목들이 어떤 의미를 갖는지,
환경 설정파일에서 어떻게 표현되어 있는지 알아야 함.
```

- 필요한 정보

  - SSH 환경 설정파일 경로 : /etc/ssh/sshd_config
  - 많이 사용되는 환경 설정 항목
    - Port : SSH 기본 포트인 22번을 다른 번호로 변경할 때 주로 사용함
    - PermitRootLogin : root 계정으로 SSH 접근을 허용할지 여부
    - PasswordAuthentication : 패스워드를 이용한 인증을 허용할지에 대한 여부
    - PubkeyAuthentication : 퍼블릭키를 이용한 인증을 허용할지에 대한 여부

  ```
  # Port는 22번이 기본 포트이며, 주석 처리되어 있음
  cat /etc/ssh/sshd_config | grep 'Port'
  #Port 22
  
  # Root 계정으로 SSH 접근 허용할지 여부, 기본적으로 접근 불가
  cat /etc/ssh/sshd_config | grep 'PermitRootLogin'
  #PermitRootLogin prohibit-password
  
  # SSH 접근 시 패스워드로 접근을 허용할지 여부이며, 기본적으로 패스워드 접근
  cat /etc/ssh/sshd_config | grep 'PasswordAuthentication'
  #PasswordAuthentication yes
  
  # SSH 접근 시 SSH 키를 통해 접근을 허용할지 여부이며, 기본적으로 허용
  cat /etc/ssh/sshd_config | grep 'PubkeyAuthentication'
  #PubkeyAuthentication yes
  ```

- 프로세스

  - 환경 설정파일 경로를 변수에 저장
  - switch case문을 이용하여 해당 번호를 입력받으면 환경 설정을 함
  - 해당 경로에서 해당 항목을 찾아 sed를 이용하여 값을 변경하고, 파일에 적용
  - 설정 변경이 되었으면 SSH 서비스를 재시작
  - 운영체제가 레드햇 리눅스이고, Port를 변경했다면 Selinux 설정을 변경



#### 스크립트 생성

```sh
#!/bin/bash

conf_path=/etc/ssh/sshd_config

function restart_system(){
    echo "Restart sshd"
    systemctl restart sshd
}

function selinux(){
    # 운영체제가 레드햇 리눅스이고, port를 수정했을 경우
    if [[ $(cat /etc/*release | grep -i redhat | wc -1) > 1 ]] && [[ $1 == 1 ]]
    then
        # selinux에 해당 port 추가
        echo "Add port $port to selinux"
        
        # 레드햇 계열의 리눅스를 사용할 경우
        # 보안을 위해 사용되는 selinux의 ssh 포트에 변경한 포트를 추가함으로써
        # 추가한 port를 ssh 용도로 사용할 수 있도록 허용
        semanage port -a -t ssh_port_t -p tcp $port
    fi
}

# 환경 설정파일 백업
# 기존 환경 설정파일을 환경 설정을 변경하기 전에 만일을 대비해 백업본을 만들어 줌.
# ${변수명}을 사용한 이유는 뒤에 오는 .bak과 구분하기 위해서며,
# 언제 작업을 했는지 알기 쉽도록 date 명령문을 써 년월일을 파일명 뒤에 오도록 함
cp $conf_path ${conf_path}.bak.$(date +%Y%M%d)

case $1 in

    # Port 변경
    1)
    read -p "Please input port: " port
    
    # 기존 설정 정보를 사전에 확인하여 해당 라인을 변경할 수 있도록 하기 위해 변수 저장
    # 또한 설정을 변경했는데, 다른 값으로 다시 변경을 해야할 경우에도
    # 해당 라인을 찾아 변경하기 때문에 좀 더 정확도를 높일 수 있음
    exist_conf=$(cat $conf_path | grep -e '^#Port' -e '^Port')
    sed -i "s/$exist_conf/Port $port/g" $conf_path
    restart_system
    selinux $1
    ;;

    # PermitRootLogin 변경
    2)
    read -p "Please input PermitRootLogin yes or no: " rootyn
    exist_conf=$(cat $conf_path | grep -e '^#PermitRootLogin' -e '^PermitRootLogin')
    sed -i "s/$exist_conf/PermitRootLogin $rootyn/g" $conf_path
    restart_system
    ;;

    # PasswordAuthentication 변경
    3)
    read -p "Please input PasswordAuthentication yes or no: " pwyn
    exist_conf=$(cat $conf_path | grep -e '^#PasswordAuthentication' -e '^PasswordAuthentication')
    sed -i "s/$exist_conf/PasswordAuthentication $pwyn/g" $conf_path
    restart_system
    ;;

    # PubkeyAuthentication 변경
    4)
    read -p "Please input PubkeyAuthentication yes or no: " keyyn
    exist_conf=$(cat $conf_path | grep -e '^#PubkeyAuthentication' -e '^PubkeyAuthentication')
    sed -i "s/$exist_conf/PubkeyAuthentication $keyyn/g" $conf_path
    restart_system
    ;;
    *)

    echo "Please input with following number"
    echo "1) Port 2) PermitRootLogin 3) PasswordAuthentication 4) PubkeyAuthentication"
    echo "Usage: config-sshd.sh 2"

esac
```

---



## 2. NTP 서버 환경 설정할 때

#### 상황

```
NTP는 Network Time Protocol의 약자로 서버 간의 시간을 동기화할 때 주로 사용.
또한 인터넷이 되지 않는 환경이나, 회사 내부에서 사용할 목적으로 자체 NTP 서버를 구축하는 경우도 있음.
NTP 서버는 말 그대로 ntp를 설치하여 구축할 수도 있고,
최근 ntp를 보완하여 나온 chrony를 설치하여 구축하는 경우도 있음.
이때 스크립트를 이용하여 설치되어 있는 ntp 패키지를 확인하고 해당 환경 설정을 수정할 경우
셸 스크립트를 이용할 수 있으며, 여러 시스템을 구축할 때 셸 스크립트를 이용하여 환경 설정파일을 수정할 수 있음.
```



#### 방법 찾기

```
NTP 설정 변경 시 주로 설정하는 항목들을 알아보고, 해당 항목들이 어떤 의미를 갖는지,
환경 설정파일에서 어떻게 표현되어 있는지 알아야 함.
```

- 필요한 정보
  - Chrony일 경우 환경 설정파일 경로 : /etc/chrony.conf
  - NTP일 경우 환경 설정파일 경로 : /etc/ntp.conf
  - 설정될 환경 설정 항목들
    - ntp server pool : ntp.conf와 chrony.conf에서 동일하게 사용되는 ntp 서버 목록
    - allow : ntp를 접근할 수 있는 네트워크 대역을 제한할 때 사용하며, chrony.conf에서 쓰임
    - restrict : ntp를 접근할 수 있는 네트워크 대역을 제한할 때 사용하며, ntp.conf에서 쓰임
- 프로세스
  - 파라미터로 ip 대역을 입력받아 정규 표현식에 의해 ip 대역인지를 확인
  - 잘못 입력했다면 메시지 출력
  - 설치된 ntp 패키지 정보 확인
  - 기본으로 설정되어 있는 ntp 서버 풀을 주석 처리함
  - 주석 처리된 서버 풀 아래에 로컬 서버 정보를 서버 풀로 추가함
  - IP 대역을 확인 후 있으면 allow나 restrict로 설정
  - NTP 서비스 재시작
  - Firewall에 ntp 포트 추가



#### 스크립트 생성

```sh
#!/bin/bash

ip=""
netmask=""
conf=""
service=""

# IP CIDR을 NetMask로 변경
function transfer_iprange(){

    # 외부로부터 입력받은 위치 매개변수를 매개변수 확장자 %를 사용하여 /로 시작하는 문자 뒷부분을 삭제함.
    # 예를 들어 10.10.10.0/24를 입력받았다면 /24는 삭제되고, 10.10.10.0만 남게 됨.
    ip=${1%/*}

    # 외부로부터 입력받은 위치 매개변수를 매개변수 확장자 #을 사용하여 / 앞부분의 문자열을 모두 삭제
    # 따라서 입력받은 IP에서 / 뒷부분의 CIDR에 해당하는 부분만 남게 됨.
    # 이때 해당 숫자가 16이라면 255.255.0.0 을 netmask 변수에 저장함
    if [[ ${1#*/} == 16 ]]; then netmask="255.255.0.0"; fi
    if [[ ${1#*/} == 23 ]]; then netmask="255.255.254.0"; fi
    if [[ ${1#*/} == 24 ]]; then netmask="255.255.255.0"; fi
    if [[ ${1#*/} == 28 ]]; then netmask="255.255.240.0"; fi
}

# 문자열 길이가 0이 아니라면
if [[ -n $1 ]]; then

    # 정규 표현식을 이용하여 IP 범위를 정상적으로 입력했는지 확인
    range_chk=$(echo "$1" | grep -E "^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.0/[0-9]{2}$" | wc -l)
    
    # 정규 표현식과 다르다면 메시지를 출력하고 스크립트 종료
    if [[ range_chk -eq 0 ]]; then
        echo "This ip CIDR is wrong. Please input the right ip CIDR."
        exit;
    fi
fi

# chrony가 설치되어 있는지, npt가 설치되어 있는지 확인
if [[ -f /etc/chrony.conf ]]; then
    conf=/etc/chrony.conf
    service=chronyd.service
elif [[ -f /etc/ntp.conf ]]; then
    conf=/etc/ntp.conf
    service=ntpd.service
fi

# 환경 설정파일 백업
cp $conf ${conf}.bak.$(date +%Y%M%d)

# 서버 주소 변경
sed -i "s/^server/#server/g" $conf

# #server 3으로 시작하는 문자열 밑줄에
# a \server 127.127.1.0을 사용하여 server 127.127.1.0을 추가함
sed -i "/^#server 3/ a \server 127.127.1.0" $conf

# 파라미터로 입력받은 IP가 있고, chrony이면 allow 설정
if [[ -n $1 && -f /etc/chrony.conf ]]; then
    sed -i "/^#allow/ a \allow $1" $conf

# 파라미터로 입력받은 IP가 있고, ntp면 restrict 설정
elif [[ -n $1 && -f /etc/ntp.conf ]]; then
    transfer_iprange $1
    restrict="restrict $ip mask $netmask nomodify notrap"
    sed -i "/^#restrict/ a \restrict $restrict" $conf
fi

# 서비스 재시작
echo "systemctl restart $service"
systemctl restart $service

# 포트 추가
echo "firewall-cmd --add-service=ntp"
firewall-cmd --add-service=ntp
echo "firewall-cmd --add-service=ntp --permanant"
firewall-cmd --add-service=ntp --permanant
```

---



## 3. LVM 환경 설정할 때

#### 상황

```
LVM은 Logical Volume Manager의 약자로 여러 디바이스(Disk)를 하나의 볼륨으로 만들고,
필요에 따라 볼륨을 할당하여 사용할 수 있도록 해주는 서비스.
그래서, 대부분의 회사에서는 시스템을 구성할 때 LVM을 구성하여 주로 사용.
근래에는 오픈스택과 같은 클라우드 서비스를 도입하여 사용하거나, KVM과 같은 하이퍼바이저를 이용하여
가상머신을 생성하는 경우가 많이 늘고 있음.
이때 호스트에 설치된 운영체제와 가상머신에 설치된 운영체제에 모두 LVM이 설정되어 있을 경우,
호스트의 LVM 서비스가 가상머신의 LVM 서비스에 사용하는 디바이스까지 모두 스캔하여,
가상머신의 LVM 서비스가 정상적으로 동작하지 않을 경우가 발생함.
이런 경우에는 호스트의 LVM 환경 설정을 통해 이를 해결할 수 있음.
```



#### 방법 찾기

```
LVM 환경 설정은 /etc/lvm/lvm.conf 파일을 통해 설정할 수 있음.
LVM은 여러 디바이스를 하나의 볼륨으로 만들기 때문에
디바이스를 허용할지 또는 거부할지 등을 filter 또는 global_filter 항목을 통해 설정함.
그리고, 이런 filter 항목은 주석 처리가 되어 있음.
그렇지만, 이미 기존에 운영하고 있는 곳이라면 LVM 환경 설정이 안되어 있을 수도 있으므로,
반드시 해당 설정파일을 먼저 확인해야 함.
```

- 필요한 정보
  - LVM 환경 설정파일 경로 : /etc/lvm/lvm.conf
  - 설정될 환경 설정 항목
    - global_filter
- 프로세스
  - LVM 환경 설정을 변경할 호스트 노드 목록을 변수에 저장
  - for문을 돌면서 다음 프로세스 처리
    - grep을 이용해 lvm.conf에서 global_filter가 주석 처리되어 있는지 확인
    - 설정을 변경하기 전에 백업을 받음
    - 주석 처리되어 있다면 sed를 이용해 설정을 변경
    - 설정이 변경되었으면 LVM 관련 서비스들을 재시작함



#### 스크립트 생성

> 여러 노드에 ssh를 이용하여 명령어를 실행할 경우에는 실행할 명령어를 미리 번수에 저장
>
> ssh 명령어를 실행할 때는 해당 명령어가 저장되어 있는 변수를 대신 사용하면 코드 수를 줄일 수 있음

```sh
#!/bin/bash

# 설정 변경 대상 노드들
nodes="host01 host02 host03"

# 환경 설정 확인 명령어
cmd1=:"cat /etc/lvm/lvm.conf | grep -e '^[[:space:]]*global_filter =' | wc -l"

# 환경 설정파일 백업 명령어
cmd2="cp /etc/lvm/lvm.conf /etc/lvm/lvm.conf.bak"

# 환경 설정 변경 명령어
# 해당 호스트의 /etc/lvm/lvm.conf 파일의 # global_filter로 시작하는 라인의
# 다음 줄(\1\n)에 global_filter=[ "r|.*" ]로 내용을 대체하라는 의미
# [ ""r|.*"" ]애 더블 쌍따옴표 기호를 넣은 건 문자열에서 쌍따옴표를 표현하기 위함
cmd3="sed -i 's/\(# global_filter =.*\)/\1\n global_filter = [ ""r|.*|"" ]/g' /etc/lvm/lvm.conf"

# LVM 관련 서비스 재시작 명령어
cmd4="systemctl restart lvm2*"

# 패스워드를 입력받을 때 외부로부터의 유출을 막기 위함
# read 명령어는 셸 스크립트 수행 중 프롬프트를 통해 사용자로부터 값을 입력받아 변수에 저장하여 사용할 수 있음.
# 이때 read 명령어를 그대로 사용하면 사용자가 입력하는 패스워드가 그대로 외부로 노출됨
# read 명령어 앞, 뒤로 stty -echo, stty echo를 사용하면 패스워드 유출을 막을 수 있음
stty -echo
read -p "Please input Hosts password: " pw
stty echo

# 사용자가 패스워드를 입력하지 않았다면
if [[ -z $pw ]]

then
    echo -e "\nYou need a password for this script. Please retry script"
    exit;

fi

for node in $nodes

do
    echo -e "\n$node"
    conf_chk=$(sshpass -p $pw ssh root@$node $cmd1)
    if [[ conf_chk -eq 0 ]]
    then
        # 설정 변경 전 백업
        echo "lvm.conf backup /etc/lvm/lmv.conf.bak"
        sshpass -p $pw ssh root@$node $cmd2
        
        # sed를 이용해 설정을 변경
        echo "/etc/lvm/lvm.conf reconfiguration"
        sshpass -p $pw ssh root@$node $cmd3

        # LVM 관련 서비스 재시작
        echo "LVM related service restart"
        sshpass -p $pw ssh root@$node $cmd4
    fi

done
```

---



## 4. NFS 스토리지 마운트할 때

#### 상황

```
NFS 스토리지는 네트워크를 통해 볼륨을 사용할 수 있으며,
여러 서버에서 동시에 접근하여 볼륨을 사용할 수 있는 공유 스토리지임.
그래서, 개발 환경을 구축할 때나 데이터베이스 시스템 등을 구축할 때 정말 많이 사용됨.
이런 NFS 스토리지를 리눅스에서 사용할 경우 스토리지와 마운트할 디렉터리를 생성해야 하며,
재부팅 시에도 스토리지 연결을 유지하기 위해 /etc/fstab에 NFS 스토리지 정보를 등록해야 함.
```



#### 방법 찾기

```
NFS 스토리지 마운트는 베어메탈 환경의 호스트 서버나 가상머신 환경에서도 사용할 수 있음
```

- 필요한 정보
  - 마운트 명령어 : mount
  - 마운트할 대상 NFS 서버 경로
  - 마운트할 디렉터리
  - 마운트할 NFS 버전 및 옵션
- 프로세스
  - 마운트할 대상 NFS 서버 경로를 변수에 저장
  - 마운트할 디렉터리명을 변수에 저장
  - 마운트할 디렉터리가 있는지 체크 후 디렉터리 생성
  - 생성한 디렉터리에 마운트 대상 NFS를 기본 옵션으로 마운트
  - 마운트가 되면 mount 명령어를 이용하여 마운트된 디렉터리의 NFS 정보를 확인
  - /etc/fstab에 해당 정보 추가
  - /etc/fstab을 열러 추가된 정보를 확인



#### 스크립트 생성

```sh
#!/bin/bash

# 변수에 마운트 대상 NFS 경로 및 디렉터리 저장
nfs_server="nfs.host01:/temp"
nfs_dir=/nfs_temp

# 마운트할 디렉터리가 있는지 체크 후 없으면 디렉터리 생성
if [ ! -d $nfs_dir ]; then mkdir -p $nfs_dir; fi

# 해당 NFS와 디렉터리 마운트
mount -t nfs $nfs_server $nfs_dir

# 마운트 정보에서 마운트 타입과 옵션 추출
nfs_type=$(mount | grep $nfs_dir | awk '{print $5}')

# 마운트된 디렉터리의 속성을 추출
# 추출된 속성에서 레코드 구분 기호를 쉼표 기호로 바꿔 1, 2, 3번째 항목을 추출
nfs_opt=$(mount | grep $nfs_dir | awk '{print $6}' | awk -F ',' '{print $1","$2","$3}')

# 추출한 마운트 정보를 조합하여 /etc/fstab에 설정
# ${nfs_opt:1}은 nfs_opt에 저장된 문자열을 첫 번째 인덱스부터 마지막까지 잘라냄
echo "$nfs_server $nfs_dir $nfs_type ${nfs_opt:1} 1 1" >> /etc/fstab

# 설정한 /etc/fstab 내용 확인
cat /etc/fstab | grep $nfs_dir

# 마운트된 디렉터리 정보 확인
df -h | grep $nfs_dir
```

---



## 5. 네트워크 IP 설정할 때

#### 상황

```
네트워크 IP를 설정할 일이 많지 않은 일반 사용자들이 IP를 설정하는 것은 매우 어려운 일이 될 수 있음.
처음 네트워크 IP를 설정할 때 설정 방법들을 스크립트화해 놓는다면 필요할 경우 스크립트를 참조하여
IP 설정을 할 수도 있고, 스크립트를 이용하여 IP 설정을 할 수도 있음.
```



#### 방법 찾기

```
네트워크 IP를 설정하는 방법은 리눅스의 종류와 버전에 따라 달라짐.
설정하고자 하는 리눅스 타입과 버전에 맞게 설정해야 함.
데비안 계열에서는 우분투 18.04 LTS 버전 이상, 페도라 계열 레드햇 8이나 CentOS 8 스크립트.
```

- 필요한 정보
  - 데비안 계열에서 네트워크 설정 방법
    - netplan 파일 설정으로 변경
  - 페도라 계열에서 네트워크 설정 방법
    - nmcli 명령어를 이용하여 설정
  - 네트워크 IP 설정 시 필요한 정보들
    - Network Interface name
    - IP / CIDR
    - Gateway
    - DNS
- 프로세스
  - 운영체제 타입을 확인 후 변수에 저장
  - 네트워크 디바이스명을 조회하여 보여줌
  - 네트워크 IP 설정에 필요한 정보를 사용자로부터 입력받음
  - 네트워크 정보를 입력받지 않았을 경우 입력하라는 메시지 출력 후 스크립트 종료
  - 운영체제 타입이 페도라일 경우 nmcli를 이용해 네트워크 IP 설정
  - 운영체제 타입이 데비안일 경우 netplan 파일을 생성하여 IP 설정



#### 스크립트 생성

> 네트워크 IP 설정은 물리 서버가 될 수도 있고, 가상 서버가 될 수도 있음.
>
> 여기서는 개발환경으로 많이 사용하는 가상 서버에서의 네트워크 IP 설정

```sh
#!/bin/bash

# 운영체제 타입 확인
ostype=$(cat /etc/*release | grep ID_LIKE | sed "s/ID_LIKE=//;s/\"//g")

# 네트워크 정보를 사용자로부터 입력 받음
echo "===== Network Devices ====="

# ip a는 네트워크 디바이스 목록을 확인하는 명령어
# ip a를 통해 확인한 네트워크 목록에서 grep을 이용해 숫자로 시작하는 라인만 검색한 후
# 첫 번째 인덱스와 두 번째 인덱스의 필드값을 추출함
# 그리고 다시 grep을 이용해 로컬 호스트를 의미하는 lo와
# 가상 네트워크 디바이스를 의미하는 v로 시작하는 네트워크와
# 컨테이너에서 사용하는 t로 시작하는 네트워크를 제외하면 실제 사용 네트워크가 조회됨
# docker0 제외 d
ip a | grep '^[0-9]' | awk '{print $1" "$2}' | grep -v -e 'lo' -e 'v' -e 't' -e 'd'

read -p "Please input network interface: " net_name
read -p "Please input network ip(ex: 192.168.122.10/24): " net_ip
read -p "Please input network gateway: " net_gw
read -p "Please input network dns: " net_dns

# 하나라도 입력하지 않았을 경우 입력하라는 메시지 출력 후 스크립트 종료
if [[ -z $net_name ]] || [[ -z $net_ip ]] || [[ -z $net_gw ]] || [[ -z $net_dns ]]
then
    echo "You need to input network information. Please retry this script"
    exit;
fi

# 운영체제가 페도라 계열일 경우 nmcli 명령어를 이용하여 네트워크 IP 설정
if [[ $ostype == "fedora" ]]
then
    nmcli con add con-name $net_name type ethernet ifname $net_name ipv4.address $net_ip ipv4.gateway $net_gw ipv4.dns $net_dns ipv4.method manual
    nmcli con up $net_name
# 운영체제가 데비안 계열일 경우 netplan에 yaml 파일을 생성하여 네트워크 IP 설정
elif [[ $ostype == "debian" ]]
then
    ip_chk=$(grep $net_name /etc/netplan/*.yaml | wc -l)
    # 설정하고자 하는 IP로 설정파일이 없을 경우 관련 네트워크 yaml 파일 생성
    if [ $ip_chk -eq 0 ]
    then
        # cat 명령어와 리다이렉션을 사용하여 EOF 다음 라인부터 EOF가 나올 때까지의 모든 문자열을
        # /etc/netplan/${net_name}.yaml 파일에 저장하겠다는 의미
        cat > /etc/netplan/${net_name}.yaml << EOF
network:
    version: 2
    renderer: networkd
    ethernets:
        $net_name:
            dhcp4: no
            dhcp6: no
            addresses: [$net_ip]
            gateway4: $net_gw
            nameservers:
                addresses: [$net_dns]
EOF
        echo "cat /etc/netplan/${net_name}.yaml"
        cat /etc/netplan/${net_name}.yaml
        echo "apply netplan"
        netplan apply
    else
        echo "This $net_name is configured already."
    fi
fi
```

```
스크립트 실행 완료 후 ip address show 명령어를 이용하여 확인 가능
```

