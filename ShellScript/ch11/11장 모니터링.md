# 11장 모니터링

```
시스템이 구축되고, 운영으로 전환되면 서비스가 정상적으로 이루어지고 있는지를
확인하기 위해 운영체제, 가상 환경, 애플리케이션 환경 등을 모니터링함.
대부분은 모니터링 솔루션이나 시스템을 이용하여 모니터링을 하지만,
그런 상황이 되지 않을 경우에는 모니터링의 수집 데이터 활용으로
셸 스크립트를 사용하여 운영체제 환경을 모니터링할 수 있음.
특히 하드웨어 서버의 전원이 모두 정상적으로 켜져 있는지, 네트워킹은 제대로 되고 있는지,
CPU나 메모리와 같은 물리 자원들은 충분히 있는지 등을 인프라 관점에서 셸 스크립트를 사용하여 모니터링할 수 있음.
특히 여러 서버 환경을 모니터링할 경우 셸 스크립트를 사용하면 좀 더 효율적으로 모니터링할 수 있음.
```



## 1. IPMItool을 이용하여 서버 전원 체크할 때

#### 상황

```
모든 시스템은 물리 서버에 구성됨.
따라서, 시스템이 구성된 물리 서버에 전원이 나간다면 시스템 운영에 매우 큰 영향을 미침.
물리 서버의 전원이 정상적으로 들어와 있는지를 모니터링하는 일은 매우 중요함.
대부분의 서버 업체에서는 전용 네트워크 인터페이스를 통해 서버의 전원을 제어할 수 있는 시스템을 제공함.
그리고 리눅스에서는 IPMItool을 이용하여 시스템의 전원 상태를 체크하고 전원을 제어할 수 있음.
```



#### 방법 찾기

```
IPMI는 Intelligent Platform Management Interface의 약자로 하드웨어를 원격으로 관리하기 위한 인터페이스.
IPMI를 사용하기 위해서는 서버에 구성된 IPMI용 포트에 네트워크가 연결되어 있어야 함.
물리 서버 바이오스의 IPMI 정보에 해당 IP 및 포트, 그리고 사용자 계정 및 패스워드가 설정되어 있어야 함.
```

- 필요한 정보
  - 모니터링하고자 하는 서버의 IPMI IP, port, user ID, user password
  - 전원 체크를 위한 IPMI 명령어 : ipmitool
- 프로세스
  - 모니터링하고자 하는 서버의 IPMI IP 정보를 변수에 저장
  - IPMI 접근을 위한 해당 계정의 패스워드를 입력받음
  - for문을 돌면서 ipmitool 명령어를 이용하여 해당 서버의 전원 체크
  - 모니터링 결과는 echo 명령어를 이용해 보여줌



#### 스크립트 생성

```sh
#!/bin/bash

ipmi_hosts="192.168.0.10 192.168.0.11 192.168.0.12 192.168.0.13"
ipmi_userid="admin"

read -p "Please input ipmi password : " ipmi_pw
if [[ -z $ipmi_pw ]]; then echo "You didn't input impi password. Please retry."; exit; fi

for host in $ipmi_hosts; do
    echo "######## IPMI HOST:: $host ########"
    power_stat=$(ipmitool -I lanplus -H $host -L ADMINISTRATOR -U $ipmi_userid -P $ipmi_pw -v power status)
    echo "$power_stat"
done
```

---



## 2. 서비스 상태 체크할 때

#### 상황

```
IPMI를 이용하여 서버의 전원을 체크하고, 네트워크 상태를 확인했다면
시스템에 설치되어 있는 중요 서비스들의 상태를 확인해야 함.
서비스가 정상적으로 실행 중인지 아니면 시스템의 문제로 인해 서비스가 정지되어 있지 않은지 등을 확인해야 함.
```



#### 방법 찾기

```
리눅스에 설치된 대부분의 시스템은 systemctl 명령어를 이용하여 서비스가 실행 중인지 여부를 확인할 수 있음.
또한, 해당 서비스가 사용하는 포트 같은 경우에는 netstat 명령어를 이용하여 해당 포트가 서비스 중인지를 확인할 수 있음.
```

- 필요한 정보
  - 서비스 모니터링 대상 서버 정보
  - SSH를 통해 접근할 수 있는 전용 계정
  - 모니터링 대상 서비스들
  - 모니터링 대상 서비스 포트들
  - 서비스 상태 체크 명령어 : systemctl
  - 서비스 포트 체크 명령어 : netstat
- 프로세스
  - 서비스 모니터링 대상 서버 정보들을 변수에 저장
  - 모니터링 대상 서비스들을 변수에 저장
  - 모니터링 대상 포트들을 변수에 저장
  - for문을 돌면서 대상 서버의 서비스 상태와 포트 체크
  - echo 명령어를 이용하여 모니터링 결과를 보여줌



#### 스크립트 생성

```sh
#!/bin/bash

hosts="host01 host02"
services="httpd haproxy rabbitmq"
ports="80 443 8080 5672 15672"

for host in $hosts; do
    echo "######## HOST:: $host ########"
    
    for service in $services; do
        chk_service=$(ssh mon@$host sudo systemctl is-active $service)
        if [[ $chk_service == "active" ]]; then
            echo "$service state is active."
        else
            echo "$service state is inactive. Please check $service"
        fi
    done

    echo "***************************************"
    for port in $ports; do
        chk_port=$(ssh mon@$host sudo netstat -ntpl | grep $port | wc -l)
        if [[ $chk_port > 0 ]]; then
            echo "This port $port is open."
        else
            echo "This port $port is not found. Please check your system."
        fi
    done
    echo "***************************************"
done
```

---



## 3. 클러스터 관리 툴 Pacemaker 상태 체크할 때

#### 상황

```
리눅스에서는 HA(High Availability)를 구성할 때 pacemaker라는 클러스터 관리 툴을 주로 이용함.
시스템 이중화를 할 경우 pacemaker에 해당 시스템을 자원으로 등록하면
pacemaker가 해당 시스템에 문제가 발생했을 경우 시스템을 재시작해 주기도 하고,
주요 시스템에 문제가 발생했을 경우 시스템을 재부팅시켜 주기도 함.
모니터링 대상 시스템이 클러스터 관리 툴인 pacemaker를 사용하고 있다면 pacemaker 상태도 함께 모니터링해야 함.
```



#### 방법 찾기

```
단일 클러스터의 pacemaker 상태를 체크할 경우에는 스크립트를 사용할 필요는 없음.
시스템의 여러 인프라 요소와 함께 모니터링 해야 할 경우나
여러 클러스터의 pacemaker 상태를 확인할 경우 스크립트를 이용하면 쉽게 모니터링할 수 있음.
```

- 필요한 정보
  - Pacemaker가 구성되어 있는 서버 주소
  - SSH를 통해 접근할 수 있는 전용 계정
  - Pacemaker 상태 체크 명령어 : pcs status
- 프로세스
  - 모니터링할 대상 서버 주소를 변수에 저장
  - for문을 돌면서 대상 서버의 Pacemaker 상태 체크를 함
  - echo 명령어를 이용해 해당 결과를 보여줌



#### 스크립트 생성

> 스크립트로 모니터링을 할 경우 IP보다는 도메인명을 사용하는 것이 훨씬 좋음.
> DNS 서버가 있어 도메인 서비스를 해 주면 좋지만 그런 상황이 아니라면
> /etc/hosts에 해당 서버의 IP와 호스트명을 추가하면 IP 대신 호스트명을 사용할 수 있음.

```sh
#!/bin/bash

hosts="cluster01 cluster02"

for host in $hosts; do
    echo "######## HOST:: $host ########"

    # pacemaker는 실행 중 서비스가 잘못되어 재시작을 한 경우나
    # health check를 하여 응답이 없었을 경우에는 Failed Action으로 해당 메시지를 보여줌
    # 따라서 이상 여부를 확인하기 위해 grep -i 옵션을 이용하여 해당 결과에 잘못된 경우가 있었는지 확인하고
    # -c 옵션을 이용하여 검색된 문자열의 개수를 체크함
    chk_cluster=$(ssh -q mon@$host sudo pcs status | grep -i -c 'failed')
    if [[ $chk_cluster -eq 0 ]]; then
        echo "Pacemaker status is normal."
    else
        echo "Please check pacemaker status"
        echo "********************************"
        echo "$(ssh -q mon@$host sudo pcs status)"
    fi
done
```

---



## 4. CPU 및 메모리 상태 체크할 때

#### 상황

```
아무리 성능이 좋은 서버라고 해도 해당 서버에 많은 애플리케이션들이 설치되어 서비스되고 있다면,
CPU와 몌모리 자원을 많이 사용할 것임. 그렇기 때문에 관리하는 시스템의 CPU 및 메모리 상태는 늘 확인 필요.
해당 자원의 상태를 확인함으로써 자원 증설이나 자원 축소 등의 계획을 세울 수 있으며,
자원이 부족할 경우에는 애플리케이션 실행이 정상적으로 이뤄지지 않으므로, 이런 상황을 사전 대비할 수 있음.
```



#### 방법 찾기

```
CPU나 메모리 사용 상태는 top 명령어를 이용하여 실시간으로 모니터링할 수 있지만,
스크립트를 이용하여 사용 상태를 모니터링하기 위한 방법으로는 적합하지 않음.
따라서, CPU와 같은 경우에는 mpstat과 같은 명령어를 이용하여 사용량을 확인할 수 있으며,
메모리와 같은 경우에는 free 명령어를 이용하여 메모리 사용량을 체크할 수 있음.
```

- 필요한 정보
  - 모니터링할 대상 서버 정보
  - SSH를 통해 접근할 수 있는 전용 계정
  - CPU 상태 체크 명령어 : mpstat
  - 메모리 상태 체크 명령어 : free
- 프로세스
  - 모니터링할 대성 서버 정보를 변수에 저장
  - for문을 돌면서 CPU 사용률과 메모리 사용률을 체크
  - 모니터링 결과를 echo 명령어를 이용하여 보여줌



#### 스크립트 생성

> mpstat은 리눅스 기본 제공 명령어 아님

```sh
#!/bin/bash

hosts="host01 host02 host03"

for host in $hosts; do
    echo "######## HOST:: $host ########"
    chk_cpu=$(ssh -q mon@$host mpstat | grep all | awk '{print $4}')
    chk_mem=$(ssh -q mon@$host free -h | grep Mem | awk '{print $4}')

    echo "CPU usags is ${chk_cpu}%"
    echo "Memory free size is ${chk_mem}"
done
```

---



## 5. 서비스 로그 모니터링할 때

#### 상황

```
시스템 실행 상태뿐만 아니라, 코드에 의한 버그나 잘못한 입력 파라미터에 의한 버그 또는 관련 시스템의 문제로 인한 에러 로그 등은
서비스 사용자로부터 연락이 오지 않는 이상 모니터링을 하지 않으면 알 수 없음.
그만큼 시스템에 구축된 서비스 로그를 주기적으로 모니터링하는 것이 중요함.
수많은 서비스가 있다면, 해당 서비스들의 로그를 전부 모니터링한다는 건 쉬운 일이 아님.
```



#### 방법 찾기

```
서비스 로그 모니터링을 하기 위해서는 어떤 서비스를 모니터링할 것인지 대상 서비스가 있어야 하며,
서비스 로그가 쌓이는 대상 디렉터리를 알고 있어야 함.
또한 서버 별로 어떤 서비스가 실행되고 있는지도 함께 알아야 함.
```

- 필요한 정보
  - 서비스 로그 모니터링 대상 서버 정보
  - SSH를 통해 접근할 수 있는 전용 계정
  - 서버별 실행 서비스 및 로그 디렉터리 정보
- 프로세스
  - 서비스 로그 모니터링 대상 서버 정보들을 변수에 저장
  - for문을 통해 대상 서버의 서비스 로그를 확인
  - 확인된 결과를 echo를 이용해 보여줌



#### 스크립트 생성

> 모든 로그를 모니터링하기보다 해당 서비스에서 발생하는 에러 로그를 검색하여 모니터링하는 것이 좋음

```sh
#!/bin/bash

hosts="host01 host02"
services="httpd rabbitmq nginx"

for host in $hosts; do
    echo "######## HOST:: $host ########"
    for service in $services; do
        chk_log=$(ssh mon@$host sudo tail /var/log/$service/*.log | grep -i error | wc -l)
        if [[ $chk_log -eq 0 ]]; then
            echo "No error services logs. The $service is normal."
        else
            echo "Please check service $service logs and service $service"
            echo "$(ssh mon@$host sudo tail /var/log/$service/*.log | grep -i error)"
        fi
    done
done
```

---



## 6. 컨테이너 실행 상태 모니터링할 때

#### 상황

```
근래에는 컨테이너를 이용하여 개발하고 서비스를 하는 곳이 많음.
시스템에서 컨테이너를 이용하여 서비스를 한다면, 컨테이너 실행 상태 역시 모니터링이 필요함.
Docker를 이용하여 컨테이너 서비스를 운영하거나 개발할 경우에는 Docker 서비스 상태 확인도 필요.
```



#### 방법 찾기

```
컨테이너 실행 상태를 모니터링하기 위해서는 컨테이너 서비스가 운영 중인 서버 정보를 알아야 하며,
해당 서버의 컨테이너 엔진이 Docker인지 Podman인지도 알아야 함.
```

- 필요한 정보
  - 컨테이너 서비스가 운영 중인 서버 정보
  - 컨테이너 엔진 확인 명령어 : systemctl list-units
  - 컨테이너 실행 상태 확인 명령어 : docker ps 또는 podman ps
- 프로세스
  - 컨테이너 서비스가 운영 중인 서버 정보를 변수에 저장
  - for문을 돌면서 어떤 컨테이너 엔진이 실행 중인지 확인
  - 컨테이너 실행 상태를 확인
  - 모니터링 결과를 echo를 이용해 보여줌



#### 스크립트 생성

```sh
#!/bin/bash

hosts="host01 host02 host03"

for host in $hosts; do
    echo "######## HOST:: $host ########"
    ostype=$(cat /etc/*release | grep ID_LIKE | sed "s/ID_LIKE=//;s/\"//g")
    if [[ $ostype == "fedora" ]]; then
        chk_docker=$(ssh -q mon@$host rpm -qa | grep -c docker)
        chk_podman=$(ssh -q mon@$host rpm -qa | grep -c podman)
    elif [[ $ostype == "debian" ]]; then
        chk_docker=$(ssh -q mon@$host dpkg -l | grep -c docker)
        chk_podman=$(ssh -q mon@$host dpkg -l | grep -c podman)
    else
        echo "bye.."
        exit
    fi
    if [[ $chk_docker -gt 0 ]]; then
        echo "This system's container engine is docker."
        chk_service=$(ssh -q mon@$host systemctl is-active docker)
        if [[ $chk_service == "active" ]]; then
            echo "Docker running state is active."
            # seconds가 반복되면 문제가 있다고 볼 수 있음
            chk_container=$(ssh -q mon@$host docker ps | grep -c seconds)
            if [[ $chk_container -gt 0 ]]; then
                echo "Please check your container state."
                echo "$(ssh -q mon@$host docker ps | grep seconds)"
            else
                echo "Container status is normal."
            fi
        else
            echo "Please check your docker status."
        fi
    elif [[ $chk_podman -gt 0 ]]; then
        echo "This system's container engine is podman."
        chk_service=$(ssh -q mon@$host systemctl is-active podman)
        if [[ $chk_service == "active" ]]; then
            echo "Podman running state is active."
            chk_container=$(ssh -q mon@$host podman ps | grep -c seconds)
            if [[ $chk_container -gt 0 ]]; then
                echo "Please check your container state."
                echo "$(ssh -q mon@$host podman ps | grep seconds)"
            else
                echo "Container status is normal."
            fi
        else
            echo "Please check your podman status."
        fi
    else
        "No conatiner engine"
    fi
done
```

---



## 7. 일일 시스템 점검 모니터링하기

#### 상황

```
시스템을 모니터링할 때는 대상 시스템의 환경에 따라 모니터링 대상이 달라짐.
```



#### 가정

- 모니터링 서버 1대
- 클러스터링된 DB 및 웹 서버 3대
- 컨테이너 서비스가 운영중인 서버 3대
- 기타 일반 리눅스 서버 5대



#### 방법 찾기

- 필요한 정보
  - 모니터링 대상 서버 IP 또는 호스트명
  - SSH를 통해 접근한 전용 계정 및 패스워드 또는 SSH 키
  - 서버별 운영 중인 서비스 목록
- 프로세스
  - 모니터링 대상 서버 정보를 변수에 저장
  - 모니터링 결과를 화면에 출력하고, 로그 파일에 저장하기 위한 함수 생성
  - 로그 파일은 스크립트가 실행되는 해당 일과 시각으로 그때 그때 생성
  - for문을 돌면서 IPMItool을 이용해 모든 서버 전원 상태 확인
  - 클러스터링된 서버 중 첫 번째 서버에서 pacemaker 상태 확인
  - 모든 서버의 네트워크 상태 확인
  - 모든 서버의 CPU와 메모리, 디스크 사용률 확인
  - DB 서버와 웹 서버에서는 해당 서비스가 정상적으로 실행 중인지 확인
  - DB 서버와 웹 서버에서는 서비스 로그에 ERROR가 발생한 적 있는지 확인
  - 컨테이너 서비스가 운영 중인 서버에서는 컨테이너 엔진을 확인
  - 컨테이너 서비스가 운영 중인 서버에서는 컨테이너 실행 상태 점검
  - 모든 점검 결과는 화면에 보여주고, 로그 파일에 저장



#### 스크립트 생성

```sh
#!/bin/bash

cluster_servers="clus01 clus02 clus03"
container_servers="con01 con02 con03"
general_servers="gen01 gen02 gen03 gen04 gen05"
services="httpd mariadb"
grep_nic="-e eno1 -e eno3 -e enp24s0f0 -e enp24s0f1"

LOG_FILE=""

# 모니터링 로그 파일 생성
function make_logs() {
    DATE=$(date +%Y%m%d%H%M)
    LOG_FILE="/var/log/daily_system_chk/chk_system_$DATE.log"
    sudo touch $LOG_FILE
    sudo chmod 777 $LOG_FILE
}

# 모니터링 로그 파일 권한 변경
function change_log() {
    sudo chmod 644 $LOG_FILE
}

# 모니터링 결과 출력 후 로그 저장
function print_msg() {
    message=$1
    date=$(date +%Y-%m-%d %H:%M)
    echo "$date [daily_system_chk] $message" >> $LOG_FILE
    echo "$date $message"
}

function check_network() {
    print_msg "-----------------------------"
    print_msg "       Check Network         "
    print_msg "-----------------------------"
    down_link=$(ssh mon@$1 "ip link show | grep $grep_nic | grep 'state DOWN' | awk -F ': ' '{print $2}'")
    down_link_cnt=$(ssh mon@$1 "ip link show | grep $grep_nic | grep 'state DOWN' | wc -l")
    if [[ $down_link_cnt -eq 0 ]]; then
        print_msg "Network states are normal."
    else
        print_msg "Network $down_link is down. Please check network status."
    fi
}

function check_cpu() {
    print_msg "-----------------------------"
    print_msg "         Check CPU           "
    print_msg "-----------------------------"
    cpu_stat=$(ssh -q mon@$1 sudo mpstat | grep all | awk '{print $4}')
    print_msg "CPU usage is ${cpu_stat}%. If CPU usage is high, please check system cpu status"
}

function check_memory() {
    print_msg "-----------------------------"
    print_msg "       Check Memory          "
    print_msg "-----------------------------"
    mem_stat=$(ssh -q mon@$1 sudo free -h | grep -i mem | awk '{print $4}')
    print_msg "Memory free size is $mem_stat. If memory free size is low, please check system memory status."
}

make_logs
print_msg "-----------------------------"
print_msg "     Check System Power      "
print_msg "-----------------------------"

for i in {1..3}; do
    print_msg "##### NODE:: clus0$i #####"
    power_stat=$(ipmitool -I lanplus -H 192.168.0.1$i -L ADMINISTRATOR -U admin -P passw@rd! -v power status)
    print_msg "$power_stat"
done

for i in {1..3}; do
    print_msg "##### NODE:: con0$i #####"
    power_stat=$(ipmitool -I lanplus -H 192.168.0.2$i -L ADMINISTRATOR -U admin -P passw@rd! -v power status)
    print_msg "$power_stat"
done

for i in {1..5}; do
    print_msg "##### NODE:: gen0$i #####"
    power_stat=$(ipmitool -I lanplus -H 192.168.0.3$i -L ADMINISTRATOR -U admin -P passw@rd! -v power status)
    print_msg "$power_stat"
done

print_msg "-----------------------------"
print_msg "       Cluster Servers       "
print_msg "-----------------------------"

for i in $cluster_servers; do
    print_msg "##### NODE:: $i #####"
    if [ $i = "clus01" ]; then
        print_msg "-----------------------------"
        print_msg "      Check Clustering       "
        print_msg "-----------------------------"
        cluster_stat=$(ssh -q mon@$i sudo pcs status | grep 'failed' | wc -l)

        if [ $cluster_stat -eq 0 ]; then
            print_msg "Pacemaker status is normal."
        else
            print_msg "Please check Pacemaker."
            print_msg "$(ssh -q mon@$i sudo pcs status)"
        fi
    fi
    chk_network $i
    check_cpu $i
    check_memory $i
    
    print_msg "-----------------------------"
    print_msg "     Check Service Log       "
    print_msg "-----------------------------"
    for service in $services; do
        chk_log=$(ssh mon@$i sudo tail /var/log/$service/*.log | grep -i error | wc -l)
        if [[ $chk_log -eq 0 ]]; then
            echo "No error services logs. The $service is normal."
        else
            echo "Please check service $service logs"
            echo "$(ssh mon@$i sudo tail /var/log/$service/*.log | grep -i error)"
        fi
    done
done

print_msg "-----------------------------"
print_msg "     Container Servers       "
print_msg "-----------------------------"

for i in $container_servers; do
    print_msg "##### NODE:: $i #####"
    check_network $i
    check_cpu $i
    check_memory $i

    ostype=$(cat /etc/*release | grep ID_LIKE | sed "s/ID_LIKE=//;s/\"//g")
    if [[ $ostype == "fedora" ]]; then
        chk_docker=$(ssh -q mon@$i rpm -qa | grep -c docker)
        chk_podman=$(ssh -q mon@$i rpm -qa | grep -c podman)
    elif [[ $ostype == "debian" ]]; then
        chk_docker=$(ssh -q mon@$i dpkg -l | grep -c docker)
        chk_podman=$(ssh -q mon@$i dpkg -l | grep -c podman)
    else
        echo "bye.."
        exit
    fi
    if [[ $chk_docker -gt 0 ]]; then
        echo "This system's container engine is docker."
        chk_service=$(ssh -q mon@$i systemctl is-active docker)
        if [[ $chk_service == "active" ]]; then
            echo "Docker running state is active."
            chk_container=$(ssh -q mon@$i docker ps | grep -c seconds)
            if [[ $chk_container -gt 0 ]]; then
                echo "Please check your container state."
                echo "$(ssh -q mon@$i docker ps | grep seconds)"
            else
                echo "Container status is normal."
            fi
        else
            echo "Please check your docker status."
        fi
    elif [[ $chk_podman -gt 0 ]]; then
        echo "This system's container engine is podman."
        chk_service=$(ssh -q mon@$i systemctl is-active podman)
        if [[ $chk_service == "active" ]]; then
            echo "Podman running state is active."
            chk_container=$(ssh -q mon@$i podman ps | grep -c seconds)
            if [[ $chk_container -gt 0 ]]; then
                echo "Please check your container state."
                echo "$(ssh -q mon@$i podman ps | grep seconds)"
            else
                echo "Container status is normal."
            fi
        else
            echo "Please check your podman status."
        fi
    fi
done

print_msg "-----------------------------"
print_msg "       General Server        "
print_msg "-----------------------------"

for i in $general_servers; do
    print_msg "##### NODE:: $i #####"
    check_network $i
    check_cpu $i
    check_memory $i
done

change_log
```

