# 8장 시스템 구축

## 1. 사용자 계정을 만들 때

#### 상황

```
시스템을 구축하면 가장 먼저 하는 일은 사용자 계정을 만드는 일.
시스템에 접속할 사용자 계정을 만들 수도 있고, 특정 서비스를 구축하기 위한 사용자 계정을 만들 수도 있음.
물론 시스템 한 대에서 사용자 계정을 만든다면 상관없지만, 여러 서버에서 동일한 계정을 생성해야 하거나,
여러 계정을 만들어야 할 경우에는 단순하지만 많은 시간이 소요됨.
```

#### 방법 찾기

```
모든 개발에는 프로세스가 존재하며, 개발을 효율적으로 하기 위해서는 프로세스 설계가 반드시 필요함.
```

- 필요한 정보
  - 사용자 계정 ID와 패스워드 필요
  - 사용자 계정 생성 명령어 : useradd
  - 패스워드 설정 명령어: passwd
- 프로세스
  - 사용자 계정과 패스워드를 입력받음
  - 입력 정보가 없으면 에러 메시지를 보여주고 셸 스크립트를 종료함
  - 여러 명의 사용자 계정을 생성할 경우에는 for문을 이용함
  - 생성하고자 하는 사용자 계정이 있는지 확인
  - 사용자 계정이 없으면 사용자 계정을 생성하고, 패스워드를 설정
  - 만일 사용자 계정이 있으면 계정이 있다고 메시지를 보여줌



#### 스크립트 생성

###### 다수의 사용자 계정을 생성할 경우

```sh
#!/bin/bash

# 사용자 계정 및 패스워드가 입력되었는지 확인
# 입력된 문자열 길이가 0이 아니면 참을 리턴하는 문자열 연산자
# 사용자 계정과 패스워드가 모두 입력되었는지 확인하기 위한 && AND 논리 연산자 사용
# 입력되는 값이 외부에서 입력되는 파라미터이므로, [[]] 사용
if [[ -n $1 ]] && [[ -n $2 ]]
then

    # 외부에서 입력받은 사용자 계정과 패스워드를 변수에 배열로 할당
    # 여러 건의 사용자 생성과 패스워드 설정을 처리하기 위함
    UserList=($1)
    Password=($2)

    # for문을 이용하여 사용자 계정 생성
    # UserList의 길이만큼 사용자를 생성하기 위해 ${#배열형변수명[@]} 사용
    # 이렇게 표현하면 해당 변수의 길이를 구할 수 있음
    for (( i=0; i < ${#UserList[@]}; i++ ))
    do

        # if문을 사용하여 사용자 계정이 있는지 확인
        # 결과값을 개수로 세어 개수가 0이면 사용자를 아직 생성하지 않았다는 의미
        if [[ $(cat /etc/passwd | grep ${UserList[$i]} | wc -l) == 0 ]]
        then
            
            # 사용자 생성 및 패스워드 설정
            useradd ${UserList[$i]}
            echo ${Password[$i]} | passwd ${UserList[$i]} --stdin
        else
            # 사용자가 있다고 메시지를 보여줌
            echo "this user ${UserList[$i]} is existing."
        fi
    done

else
    # 사용자 계정과 패스워드를 입력하라는 메시지를 보여줌
    echo -e 'Please input user id and password.\nUsage: adduser-script.sh "user01 user02" "pw01 pw02"'

fi
```



###### 여러 서버에 동일한 사용자 계정을 만들 경우

```sh
#!/bin/bash

for server in "host01 host02 host03"

do    
    # 여러 대의 시스템에 사용자 생성 및 패스워드 설정
    echo $server

    # ssh를 이용해 서버에 접속할 경우 for문에서 선언된 server라는 변수를 사용했음
    # ssh 접속 정보를 선언한 후에는 해당 서버에서 실행할 명령어를 적어주면 되는데
    # 이때 사용자 생성을 위한 useradd 명령어와 패스워드 설정을 위한 passwd 명령어를 사용함
    # 또한 명령어와 명령어에 넘겨줄 파라미터는 쌍따옴표로 묶어주면
    # 명령어가 어디서부터 어디까지인지를 정확하게 인식할 수 있음
    ssh root@$server "useradd $1"
    ssh root@$server "echo $2 | passwd $1 --stdin"

done
```

---



## 2. SSH Key를 여러 서버에 복사할 때

#### 상황

```
시스템을 구축하고, 애플리케이션을 설치할 경우 해당 애플리케이션을 사용하는 서버들끼리
ssh 접속을 할 때 패스워드 대신 SSH 키를 주로 사용함.
그리고, SSH 공개 키를 복사하여 패스워드 입력 없이 서버에 접속함.
이와 같은 경우에도 서버가 한두 대라면 상관없지만, 3대 이상이면 매우 번거로움.
```



#### 방법 찾기

```
셸 스크립트를 이용하여 SSH 키를 복사하기 위해서는 SSH 키를 먼저 생성한 후 해당 키를 여러 서버에 복사함.
이때 어떤 계정으로 키를 복사할지 여부와 해당 계정의 패스워드를 알고 있어야 함.
```

- 필요한 정보
  - SSH Key 생성 명령어 : ssh-keygen
  - SSH Key 복사 명령어 : ssh-copy-id
  - 접속할 서버 정보 : IP, 접속 계정 및 패스워드
- 프로세스
  - 접속할 서버 정보 및 SSH 키, 공개 키 경로를 변수에 저장
  - SSH Key를 생성
  - 생성한 SSH 공개 키를 해당 서버에 복사



#### 스크립트 생성

```sh
#!/bin/bash

# 접속할 서버 정보, SSH 키 경로, 공개 키 경로를 변수에 저장
servers="host01 host02"
sshKey="$HOME/.ssh/key.pem"
sshPub="$HOME/.ssh/key.pem.pub"

# SSH Key 생성
# -f : output_keyfile
ssh-keygen -q -N "" -f $sshKey

# 생성된 SSH Key를 해당 서버에 복사
for server in servers

do
    echo $server

    # 공개 키를 해당 서버에 복사할 때 해당 서버에 접속할 것인지 물어보는 메시지와
    # 패스워드가 무엇인지 물어보는 메시지를 없애기 위해
    # sshpass 명령어와 ssh-copy-id 명령어를 사용하여 복사
    # 패스워드는 보안을 위해 스크립트를 실행할 때 입력받는 것이 좋음.
    sshpass -p "$1" ssh-copy-id -i $sshPub stack@server

done
```

---



## 3. 다수의 서버에 NTP 서버를 설치할 때

#### 상황

```
NTP는 Network Time Protocol의 약자로 특정 애플리케이션 서비스를 위해
클러스터로 묶여 있는 서버들의 시간을 동기화하기 위해 설치하는 서비스.
만약 서버 간의 시간이 서로 맞지 않을 경우에는 데이터의 생성 시간이 서로 맞지 않아 오류가 발생하기도 함.
```



#### 방법 찾기

```
NTP를 설치하기 위해서는 패키지 리포지터리가 설정되어 있어야 하며,
오픈소스 리눅스 같은 경우에는 인터넷이 되는 환경이어야 함.
만일 인터넷이 안되는 환경이라면 내부에 로컬 리포지터리를 가지고 있어야 함
```

- 필요한 정보
  - NTP 설치 명령어 : 페도라 계열 리눅스 - yum install ntp
  - NTP 설치 명령어 : 데비안 계열 리눅스 - apt-get install ntp
  - NTP 서버 정보, NTP를 설치할 대상 서버 정보
- 프로세스
  - NTP를 설치할 대상 서버 정보를 변수에 저장
  - 리눅스가 페도라 계열인지 데비안 계열인지 체크
  - 페도라 계열이면 yum install ntp로 설치
  - 데비안 계열이면 apt-get install ntp로 설치



#### 스크립트 생성

> SSH를 통해 NTP를 설치하려면 root 권한이 있는 사용자 계정이나 root 계정을 사용해야 함

```sh
#!/bin/bash

# NTP를 설치할 대상 서버정보 저장
servers="host01 host02 host03"

# 페도라 계열의 리눅스는 /etc/redhat-release에서 운영체제 타입 확인
# 데비안 계열의 리눅스는 /etc/os-release에서 운영체제 타입 확인
# 이때, 운영체제 타입에 해당하는 옵션값이 바로 ID_LIKE
# 따라서 cat을 이용해 /etc/*release 파일을 확인하여 grep으로 ID_LIKE를 조회하면 해당 값 알 수 있음
# 여기서 값은 ID_LIKE="fedora" 혹은 ID_LIKE=debian으로 조회되기 때문에
# sed 명령어를 이용해 ID_LIKE=를 공백으로 변경함
# 그리고 "fedora" 같은 경우에는 앞뒤에 붙어 있는 쌍따옴표를 없애줘야 함
cmd1='cat /etc/*release | grep ID_LIKE | sed "s/ID_LIKE=//;s/\"//g"'
cmd2=''

for server in $servers; do
    # 해당 서버의 운영체제 타입 확인
    ostype=$(sshpass -p $1 ssh root@$server $cmd1)

    # 운영체제가 페도라 계열인지 데비안 계열인지 체크
    if [[ $ostype == "fedora" ]]; then
        cmd2="yum install ntp -y"
    elif [[ $ostype == "debian" ]]; then
        cmd2="apt-get install ntp -y"
    fi

    # 해당 운영체제에 ntp 설치
    # 이때 ssh 접속 계정은 설치 명령어를 사용하므로
    # root 계정이나 root 권한을 가진 사용자 계정을 사용해야 함
    sshpass -p $1 ssh root@server $cmd2

done
```

---



## 4. 다수의 서버에 TimeZone을 설정할 때

#### 상황

```
시간을 표현할 때 UTC를 기준으로 각 나라마다 설정하는 시간 기준이 달라짐.
이때 해당 지역의 표준시간을 설정하는 기준을 Timezone이라고 함. 대한민국의 Timezone은 'Asia/Seoul'임.
시스템을 설치할 때 Timezone까지 모두 설정하여 시스템을 설치하면 좋겠지만,
미처 그렇게 하지 못했을 경우에는 일일이 모든 시스템에 들어가서 Timezone을 확인해야 할 상황이 생김.
```



#### 방법 찾기

- 필요한 정보
  - Timezone을 확인하기 위한 명령어 : timedatectl status
  - Timezone을 설정하기 위한 명령어 : datetimectl set-timezone
- 프로세스
  - 파라미터로 입력받은 Timezone을 변수에 저장
  - 해당 서버의 Timezone을 확인하기 위한 명령어 저장
  - for문을 돌면서 해당 서버의 Timezone을 확인
  - 입력받은 Timezone과 해당 서버의 Timezone이 일치하는지 확인
  - 일치하지 않으면 입력받은 Timezone으로 해당 서버의 Timezone을 변경



#### 스크립트 생성

```sh
#!/bin/bash

# Timezone을 설정할 대상 정보 및 명령어 저장
servers="host01 host02 host03"
cmd1="timedatectl status | grep 'Time zone'"
cmd2="timedatectl set-timezone $1"

# Timezone 또는 패스워드 둘 중 하나라도 입력하지 않았다면 스크립트 종료
# 연산자 -z는 변수의 길이가 0이면 true를 리턴하는 연산자로써
# timezone이나 접속하고자 하는 서버의 패스워드를 입력하지 않은 경우
# echo를 이용하여 메시지를 보여주고, 스크립트 종료
if [[ -z $1 ]] || [[ -z $1 ]]; then
    echo -e 'Please input timezone and password\nUsage: sh set-timezone.sh Seoul/Asia password'
    exit;
fi

for server in $servers

do
    # 해당 서버의 설정된 timezone 정보 조회
    # timedatectl status 명령어를 실행하면 "Time zone: Asia/Seoul (KST, +0900)"과 항목 확인 가능
    # 해당 Time zone이 포함된 라인만 조회하기 위해 grep 명령어를 사용하였고
    # 조회된 결과에서 awk를 이용하여 3번째 인덱스에 해당되는 timezone 정보만 추출해낼 수 있음
    timezone=$(sshpass -p $2 ssh root@$server "$cmd1" | awk '{print $3}')
    echo "$server: $timezone"

    # 설정하고자 하는 timezone과 조회된 timezone이 다른지 확인
    if [[ $timezone != $1 ]]
    
    then
        # timezone이 서로 다르면 해당 서버에 입력받은 timezone으로 설정
        sshpass -p $2 ssh root@$server $cmd2
        echo "$server timezone changed to $1"

    fi

done
```



#### Timezone 목록 확인

```
timedatectl list-timezones
timedatectl list-timezones | grep Seoul
```

---



## 5. CLI를 이용하여 오픈스택 인스턴스를 생성할 때

#### 상황

```
오픈스택은 기업의 퍼블릭 클라우드 시스템이나 프라이빗 클라우드 시스템을 구축할 때 사용하는 오픈소스 소프트웨어.
오픈스택을 사용하는 곳은 대체적으로 포털이나 대시보드를 이용하여 인스턴스를 생성하지만,
운영을 하다 보면 때로는 명령어를 이용하여 인스턴스를 생성해야 할 경우가 종종 있음.
인스턴스를 생성하기 위해서는 여러 가지 정보가 필요하고, 인스턴스 생성 명령어 또한 복잡함.
```



#### 방법 찾기

- 필요한 정보
  - 이미지 조회 명령어 : openstack image list
  - 네트워크 조회 명령어 : openstack network list
  - Flavor 조회 명령어 : openstack flavor list
  - 보안그룹 조회 명령어 : openstack security group list
  - SSH 키 조회 명령어 : openstack keypair list
  - 인스턴스 생성 명령어 : openstack server create
- 프로세스
  - 인스턴스명을 입력받음
  - 이미지 정보를 보여주고 생성하고자 하는 이미지명을 입력받음
  - 네트워크 정보를 보여주고 네트워크명을 입력받음
  - Flavor 정보를 보여주고 Flavor명을 입력받음
  - 보안그룹 정보를 보여주고 보안그룹명을 입력받음
  - SSH 키 정보를 보여주고 SSH 키를 입력받음
  - 앞에서 입력받은 데이터를 이용하여 인스턴스 생성



#### 스크립트 생성

```sh
#!/bin/bash

# 인스턴스명 입력
# read 명령어는 외부 사용자로부터 파라미터를 직접 입력받을 때 사용하는 명령어
# -p 옵션은 프롬프트 메시지를 함께 보여줄 때 사용하는 옵션
# vmname은 사용자로부터 입력받은 문자열을 저장하기위해 사용하는 변수
read -p "Input instance name : " vmname

# 이미지 정보
echo "=== image List ==="

# 오픈스택 명령어를 사용할 때 -c 옵션을 사용하면 특정 컬럼 정보만 조회할 수 있음.
# 따라서 -c Name은 Name 컬럼만 출력하겠다는 의미.
# -f value 옵션은 출력 시 헤더값을 제외하고, 결과값만 출력하겠다는 의미
openstack image list -c Name -f value
read -p "Input image name : " image

# 네트워크 정보
echo "=== Network List ==="
openstack network list -c Name -f value
read -p "Input network name : " net

# Flavor 정보
echo "=== Flavor List ==="
openstack flavor list -c Name -f value
read -p "Input flavor name : " flavor

# 보안그룹 정보
echo "=== Security group List ==="
openstack security group list --project $OS_PROJECT_NAME -c Name -f value
read -p "Input security group name : " sec
secgrp=$(openstack security group list --project $OS_PROJECT_NAME -f value -c ID -c Name | grep "$sec\$" | awk '{print $1}')

# SSH 키 정보
echo "=== Keypair List ==="
openstack keypair list -c Name -f value
read -p "Input keypair name : " keypair

# 볼륨 생성
echo "=== Create volume ==="
read -p "Input volume size : " size
openstack volume create --size $size --image $image --bootable $vmname

# 인스턴스 생성
echo "Create Instance Starting"
openstack server create \
--volume $(openstack volume list --name $vmname -f value -c ID) \
--flavor $flavor \
--security-group $secgrp \
--key-name $keypair \
--network $net \
--wait \
$vmname
```

---



## 6. 패키지 리포지터리 다운로드할 때

#### 상황

```
대부분의 회사에 구축되는 리눅스 서버들은 인터넷이 되지 않는 환경에서 구축되는 경우가 많음.
그래서, 회사 내부에 패키지 리포지터리를 구성하는 경우가 많음.
그런 경우에 시스템 엔지니어는 인터넷이 되는 DMZ 구간의 서버에서
외부 리포지터리와 내부 리포지터리를 정기적으로 동기화해야 함.
특히 기업에서 주로 쓰는 레드햇 리눅스일 경우 이런 작업을 해야 할 기회가 더 많음.
이런 경우 셸 스크립트를 이용하면 매번 명령어를 사용하지 않고, 쉽게 리포지터리의 패키지들을 다운로드할 수 있음.
우분투와 같은 데비안 계열의 리눅스에도 패키지 리포지터리를 동기화하는 방법이 있지만, 많이 사용하지 않음.
```



#### 방법 찾기

- 필요한 정보
  - 패키지 리포지터리 동기화 명령어 : reposync
  - 디렉터리의 리포지터리화 하는 명령어 : createrepo
- 프로세스
  - 동기화를 할 리포지터리는 외부로부터 입력받아 변수에 저장
  - 리포지터리를 저장할 경로를 저장
  - 운영체제 버전 확인
  - 리포지터리 동기화
  - 동기화가 끝나면 리포지터리를 다운로드 받은 경로를 createrepo를 통해 리포지터리화 함



#### 스크립트 생성

> 리포지터리 서버를 만들기 위해서 주로 아파치 웹 서버를 사용함
>
> 그리고, 레드햇 리눅스와 같은 경우에는 서브스크립션을 등록해야 함
>
> 레드햇 리눅스 7 버전과 레드햇 리눅스 8 버전에서 사용할 수 있는 셸 스크립트

```sh
#!/bin/bash

# 리포지터리 목록을 입력받지 않고, 파일에 직접 입력해도 됨
repolist=$1
repopath=/var/www/html/repo/

# /etc/redhat-release에는 레드햇 리눅스 이름과 버전이 적혀 있음
# 여기서 버전 정보만 가져오기 위해 awk 명령어를 이용해
# 총 필드수 - 1번째의 문자열을 추출하면 레드햇 버전만 가져올 수 있음
osversion=$(cat /etc/redhat-release | awk '{print $(NF-1)}')

# 리포지터리 입력이 없으면 메시지를 보여주고 스크립트 종료
if [[ -z $1 ]]; then
    echo "Please input repository list. You can get repository from [yum repolist]"
    echo "Rhel7 Usage: reposync.sh \"rhel-7-server-rpms\""
    echo "Rhel8 Usage: reposync.sh \"rhel-8-for-x86_64-baseos-rpms\""
    exit;
fi

# 운영체제 버전에 따라 입력한 리포지터리만큼 동기화를 함
for repo in $repolist; do
    # OS가 Rhel7일 경우
    # 위에서 가져온 버전 정보는 아마도 7.x나 8.x일 것임
    # 여기서 가장 앞문자 하나를 추출하기 위해 ${변수:시작위치:길이}를 사용해
    # 운영체제 버전이 7인지 8인지 확인
    if [ ${osversion:0:1} == 7 ]; then
        reposync --gpgcheck -l -n --repoid=$repo --download_path=$repopath
        createrepo $repopath$repo
    
    # OS가 Rhel8일 경우
    elif [ ${osversion:0:1} == 8 ]; then
        reposync --download-metadata --repo=$repo -p $repopath
    fi

done
```

